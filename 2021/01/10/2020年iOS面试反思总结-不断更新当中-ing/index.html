<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css">
  <script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Object-C 系列面试题总结基础题：1.Objective-C 的类可以多重继承么？可以实现多个接口么？Category 是什么？重写一个类的方式用继承好还是分类好？为什么不要在 category 中重写一个类原有的方法？ 答：Objective-c 的类不可以有多继承，OC 里面都是单继承，多继承可以用 protocol 委托代理来模拟实现可以实现多个接口，可以通过实现多个接口完成 OC 的">
<meta property="og:type" content="article">
<meta property="og:title" content="2020年iOS面试反思总结-不断更新当中-ing">
<meta property="og:url" content="http://example.com/2021/01/10/2020%E5%B9%B4iOS%E9%9D%A2%E8%AF%95%E5%8F%8D%E6%80%9D%E6%80%BB%E7%BB%93-%E4%B8%8D%E6%96%AD%E6%9B%B4%E6%96%B0%E5%BD%93%E4%B8%AD-ing/index.html">
<meta property="og:site_name" content="Arise">
<meta property="og:description" content="Object-C 系列面试题总结基础题：1.Objective-C 的类可以多重继承么？可以实现多个接口么？Category 是什么？重写一个类的方式用继承好还是分类好？为什么不要在 category 中重写一个类原有的方法？ 答：Objective-c 的类不可以有多继承，OC 里面都是单继承，多继承可以用 protocol 委托代理来模拟实现可以实现多个接口，可以通过实现多个接口完成 OC 的">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-01-10T04:23:54.000Z">
<meta property="article:modified_time" content="2021-01-10T05:05:52.208Z">
<meta property="article:author" content="Arise">
<meta property="article:tag" content="iOS 面试题">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2021/01/10/2020%E5%B9%B4iOS%E9%9D%A2%E8%AF%95%E5%8F%8D%E6%80%9D%E6%80%BB%E7%BB%93-%E4%B8%8D%E6%96%AD%E6%9B%B4%E6%96%B0%E5%BD%93%E4%B8%AD-ing/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>2020年iOS面试反思总结-不断更新当中-ing | Arise</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Arise" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Arise</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">1</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">12</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">4</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/01/10/2020%E5%B9%B4iOS%E9%9D%A2%E8%AF%95%E5%8F%8D%E6%80%9D%E6%80%BB%E7%BB%93-%E4%B8%8D%E6%96%AD%E6%9B%B4%E6%96%B0%E5%BD%93%E4%B8%AD-ing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Arise">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arise">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          2020年iOS面试反思总结-不断更新当中-ing
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-10 12:23:54 / 修改时间：13:05:52" itemprop="dateCreated datePublished" datetime="2021-01-10T12:23:54+08:00">2021-01-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">iOS开发</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/01/10/2020%E5%B9%B4iOS%E9%9D%A2%E8%AF%95%E5%8F%8D%E6%80%9D%E6%80%BB%E7%BB%93-%E4%B8%8D%E6%96%AD%E6%9B%B4%E6%96%B0%E5%BD%93%E4%B8%AD-ing/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/01/10/2020%E5%B9%B4iOS%E9%9D%A2%E8%AF%95%E5%8F%8D%E6%80%9D%E6%80%BB%E7%BB%93-%E4%B8%8D%E6%96%AD%E6%9B%B4%E6%96%B0%E5%BD%93%E4%B8%AD-ing/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Object-C-系列面试题总结"><a href="#Object-C-系列面试题总结" class="headerlink" title="Object-C 系列面试题总结"></a>Object-C 系列面试题总结</h1><h2 id="基础题："><a href="#基础题：" class="headerlink" title="基础题："></a>基础题：</h2><h3 id="1-Objective-C-的类可以多重继承么？可以实现多个接口么？Category-是什么？重写一个类的方式用继承好还是分类好？为什么不要在-category-中重写一个类原有的方法？"><a href="#1-Objective-C-的类可以多重继承么？可以实现多个接口么？Category-是什么？重写一个类的方式用继承好还是分类好？为什么不要在-category-中重写一个类原有的方法？" class="headerlink" title="1.Objective-C 的类可以多重继承么？可以实现多个接口么？Category 是什么？重写一个类的方式用继承好还是分类好？为什么不要在 category 中重写一个类原有的方法？"></a>1.Objective-C 的类可以多重继承么？可以实现多个接口么？Category 是什么？重写一个类的方式用继承好还是分类好？为什么不要在 category 中重写一个类原有的方法？</h3><blockquote>
<p>答：<br>Objective-c 的类不可以有多继承，OC 里面都是单继承，多继承可以用 protocol 委托代理来模拟实现<br>可以实现多个接口，可以通过实现多个接口完成 OC 的多重继承<br>Category 是类别；<br>⚠️重写一个类的方式用继承好还是分类好：<br>重写一个类的方式用继承还是分类. 取决于具体情况. 假如目标类有许多的子类. 我们需要拓展这个类又不希望影响到原有的代码. 继承后比较好.<br>如果仅仅是拓展方法. 分类更好.（不需要涉及到原先的代码）<br>分类中方法的优先级比原来类中的方法高，也就是说，在分类中重写了原来类中的方法，那么分类中的方法会覆盖原来类中的方法<br>⚠️为什么不要在 category 中重写一个类原有的方法：<br>1、category 没有办法去代替子类，它不能像子类一样通过 super 去调用父类的方法实现。如果 category 中重写覆盖了当前类中的某个方法，那么这个当前类中的原始方法实现，将永远不会被执行，这在某些方法里是致命的。(ps: 这里提一下，+(void)load 方法是一个特例，它会在当前类执行完之后再在 category 中执行。)<br>2、同时，一个 category 也不能可靠的覆盖另一个 category 中相同的类的相同的方法。例如 UIViewController+A 与 UIViewController+B，都重写了 viewDidLoad，我们就无法控制谁覆盖了谁。<br>3、通过观察头文件我们可以发现，Cocoa 框架中的许多类都是通过 category 来实现功能的，可能不经意间你就覆盖了这些方法中的其一，有时候就会产生一些无法排查的异常原因。<br>4、category 的诞生只是为了让开发者更加方便的去拓展一个类，它的初衷并不是让你去改变一个类。<br>结论：<br>要重写方法，当然我们首推通过子类重写父类的方法，在一些不方便重写的情况下，我们也可以在 category 中用 runtime 进行 method swizzling(方法的偷梁换柱) 来实现。</p>
</blockquote>
<a id="more"></a> 

<h3 id="2-请说明并比较以下关键词：strong-weak-assign-copy。"><a href="#2-请说明并比较以下关键词：strong-weak-assign-copy。" class="headerlink" title="2. 请说明并比较以下关键词：strong, weak, assign, copy。"></a>2. 请说明并比较以下关键词：strong, weak, assign, copy。</h3><blockquote>
<p>答：</p>
<ul>
<li>  strong 表示指向并拥有该对象。其修饰的对象引用计数会增加 1。该对象只要引用计数不为 0 则不会被销毁。当然强行将其设为 nil 可以销毁它。</li>
<li>  weak 表示指向但不拥有该对象。其修饰的对象引用计数不会增加。无需手动设置，该对象会自行在内存中销毁。</li>
<li>  assign 主要用于修饰基本数据类型，如 NSInteger 和 CGFloat，这些数值主要存在于栈上。</li>
<li>  weak 一般用来修饰对象，assign 一般用来修饰基本数据类型。原因是 assign 修饰的对象被释放后，指针的地址依然存在，造成野指针，在堆上容易造成崩溃。而栈上的内存系统会自动处理，不会造成野指针。</li>
<li>  copy 与 strong 类似。不同之处是 strong 的复制是多个指针指向同一个地址，而 copy 的复制每次会在内存中拷贝一份对象，指针指向不同地址。copy 一般用在修饰有可变对应类型的不可变对象上，如 NSString, NSArray, NSDictionary。</li>
<li>  Objective-C 中，基本数据类型的默认关键字是 atomic, readwrite, assign；普通属性的默认关键字是 atomic, readwrite, strong。</li>
</ul>
</blockquote>
<h3 id="3-用-property-声明的-NSString-NSArray-NSDictionary-经常使用-copy-关键字，为什么？如果改用-strong-关键字，可能造成什么问题？"><a href="#3-用-property-声明的-NSString-NSArray-NSDictionary-经常使用-copy-关键字，为什么？如果改用-strong-关键字，可能造成什么问题？" class="headerlink" title="3. 用 @property 声明的 NSString / NSArray / NSDictionary 经常使用 copy 关键字，为什么？如果改用 strong 关键字，可能造成什么问题？"></a>3. 用 @property 声明的 NSString / NSArray / NSDictionary 经常使用 copy 关键字，为什么？如果改用 strong 关键字，可能造成什么问题？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作（就是把可变的赋值给不可变的），为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。</span><br><span class="line">1\. 因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本。</span><br><span class="line">2\. 如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性。</span><br><span class="line">&#x2F;&#x2F;总结：使用copy的目的是，防止把可变类型的对象赋值给不可变类型的对象时，可变类型对象的值发送变化会无意间篡改不可变类型对象原来的值。</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="4-浅拷贝和深拷贝的区别？"><a href="#4-浅拷贝和深拷贝的区别？" class="headerlink" title="4. 浅拷贝和深拷贝的区别？"></a>4. 浅拷贝和深拷贝的区别？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">浅拷贝：只复制指向对象的指针，而不复制引用对象本身。</span><br><span class="line">深拷贝：复制引用对象本身。内存中存在了两份独立对象本身，当修改A时，A_copy不变。</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://www.cocoachina.com/articles/17275">iOS 深浅拷贝</a></p>
<h3 id="5-Objective-C-如何对内存管理的，说说你的看法和解决方法？"><a href="#5-Objective-C-如何对内存管理的，说说你的看法和解决方法？" class="headerlink" title="5.Objective-C 如何对内存管理的，说说你的看法和解决方法？"></a>5.Objective-C 如何对内存管理的，说说你的看法和解决方法？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">答：Objective-C的内存管理主要有三种方式ARC(自动内存计数)、手动内存计数、内存池。</span><br><span class="line">1). 自动内存计数ARC：由Xcode自动在App编译阶段，在代码中添加内存管理代码。</span><br><span class="line">2). 手动内存计数MRC：遵循内存谁申请、谁释放；谁添加，谁释放的原则。</span><br><span class="line">3). 内存释放池Release Pool：把需要释放的内存统一放在一个池子中，当池子被抽干后(drain)，池子中所有的内存空间也被自动释放掉。内存池的释放操作分为自动和手动。自动释放受runloop机制影响。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="6-继承、分类和类扩展"><a href="#6-继承、分类和类扩展" class="headerlink" title="6. 继承、分类和类扩展"></a>6. 继承、分类和类扩展</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">1\. 分类有名字，类扩展没有分类名字，是一种特殊的分类。</span><br><span class="line">2\. 分类只能扩展方法（属性仅仅是声明，并没真正实现），类扩展可以扩展属性、成员变量和方法。</span><br><span class="line">3\. 继承可以增加，修改或者删除方法，并且可以增加属性。</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://blog.csdn.net/u013602835/article/details/80918042">iOS 中 Category 和 Extension 原理详解</a></p>
<p><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://blog.csdn.net/benbenhai1999/article/details/51504590">IOS 分类 (category)、扩展(Extension) 和继承（inheritance）的区别？</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/31fae4d81607">iOS 成员变量 实例变量 属性变量</a></p>
<h3 id="7-我们说的-OC-是动态运行时语言是什么意思？"><a href="#7-我们说的-OC-是动态运行时语言是什么意思？" class="headerlink" title="7. 我们说的 OC 是动态运行时语言是什么意思？"></a>7. 我们说的 OC 是动态运行时语言是什么意思？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">主要是将数据类型的确定由编译时，推迟到了运行时。简单来说, 运行时机制使我们直到运行时才去决定一个对象的类别,以及调用该类别对象指定方法。</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="8-什么是-KVO-和-KVC？谈谈-KVC-以及-KVO-的理解？"><a href="#8-什么是-KVO-和-KVC？谈谈-KVC-以及-KVO-的理解？" class="headerlink" title="8. 什么是 KVO 和 KVC？谈谈 KVC 以及 KVO 的理解？"></a>8. 什么是 KVO 和 KVC？谈谈 KVC 以及 KVO 的理解？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">KVC(key-value-coding)键值编码，是一种间接访问实例变量的方法。提供一种机制来间接访问对象的属性。</span><br><span class="line">1、给私有变量赋值。</span><br><span class="line">2、给控件的内部属性赋值（如自定义UITextFiled的clearButton，或placeholder的颜色，一般可利用runtime获取控件的内部属性名，Ivar *ivar &#x3D; class_getInstanceVariable获取实例成员变量）。</span><br><span class="line">[textField setValue:[UIColor redColor] forKeyPath:@&quot;placeholderLabel.textColor&quot;];</span><br><span class="line">3、结合Runtime，model和字典的转换（setValuesForKeysWithDictionary，class_copyIvarList获取指定类的Ivar成员列表）</span><br><span class="line"></span><br><span class="line">KVO是一种基于KVC实现的观察者模式。当指定的被观察的对象的属性更改了，KVO会以自动或手动方式通知观察者。</span><br><span class="line">事例：监听 ScrollView 的 contentOffSet属性</span><br><span class="line">[scrollview addObserver:self forKeyPath:@&quot;contentOffset&quot;  options:NSKeyValueObservingOptionNew context:nil];</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://user-gold-cdn.xitu.io/2019/9/25/16d67d070bee8cb7?imageView2/0/w/1280/h/960/ignore-error/1">KVO 图</a></p>
<h3 id="9-block-的注意点"><a href="#9-block-的注意点" class="headerlink" title="9.block 的注意点"></a>9.block 的注意点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">1\. 在block内部使用外部指针且会造成循环引用情况下，需要用__weak修饰外部指针：</span><br><span class="line">    __weak typeof(self) weakSelf &#x3D; self; </span><br><span class="line">2\. 在block内部如果调用了延时函数还使用弱指针会取不到该指针，因为已经被销毁了，需要在block内部再将弱指针重新强引用一下。</span><br><span class="line">    __strong typeof(self) strongSelf &#x3D; weakSelf;</span><br><span class="line">3\. 如果需要在block内部改变外部栈区变量的话，需要在用__block修饰外部变量。</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="10-堆、栈和队列"><a href="#10-堆、栈和队列" class="headerlink" title="10. 堆、栈和队列"></a>10. 堆、栈和队列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">1.从管理方式来讲</span><br><span class="line">对于栈来讲，是由编译器自动管理，无需我们手工控制；</span><br><span class="line">对于堆来说，释放工作由程序员控制，容易产生内存泄露(memory leak)</span><br><span class="line">2.从申请大小大小方面讲</span><br><span class="line">栈空间比较小</span><br><span class="line">堆控件比较大</span><br><span class="line">3.从数据存储方面来讲</span><br><span class="line">栈空间中一般存储基本类型，对象的地址</span><br><span class="line">堆空间一般存放对象本身，block的copy等</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line"># 堆</span><br><span class="line">堆是一种经过排序的树形数据结构，每个节点都有一个值，通常我们所说的堆的数据结构是指二叉树。所以堆在数据结构中通常可以被看做是一棵树的数组对象。而且堆需要满足一下两个性质：</span><br><span class="line"></span><br><span class="line">1）堆中某个节点的值总是不大于或不小于其父节点的值；</span><br><span class="line"></span><br><span class="line">2）堆总是一棵完全二叉树。</span><br><span class="line"></span><br><span class="line">堆分为两种情况，有最大堆和最小堆。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆，在一个摆放好元素的最小堆中，父结点中的元素一定比子结点的元素要小，但对于左右结点的大小则没有规定谁大谁小。</span><br><span class="line"></span><br><span class="line">堆常用来实现优先队列，堆的存取是随意的，这就如同我们在图书馆的书架上取书，虽然书的摆放是有顺序的，但是我们想取任意一本时不必像栈一样，先取出前面所有的书，书架这种机制不同于箱子，我们可以直接取出我们想要的书。</span><br><span class="line"></span><br><span class="line"># 栈</span><br><span class="line">栈是限定仅在表尾进行插入和删除操作的线性表。我们把允许插入和删除的一端称为栈顶，另一端称为栈底，不含任何数据元素的栈称为空栈。栈的特殊之处在于它限制了这个线性表的插入和删除位置，它始终只在栈顶进行。</span><br><span class="line"></span><br><span class="line">栈是一种具有后进先出的数据结构，又称为后进先出的线性表，简称 LIFO（Last In First Out）结构。也就是说后存放的先取，先存放的后取，这就类似于我们要在取放在箱子底部的东西（放进去比较早的物体），我们首先要移开压在它上面的物体（放进去比较晚的物体）。</span><br><span class="line"></span><br><span class="line">堆栈中定义了一些操作。两个最重要的是PUSH和POP。PUSH操作在堆栈的顶部加入一个元素。POP操作相反，在堆栈顶部移去一个元素，并将堆栈的大小减一。</span><br><span class="line"></span><br><span class="line">栈的应用—递归</span><br><span class="line"></span><br><span class="line"># 队列</span><br><span class="line">队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。允许插入的一端称为队尾，允许删除的一端称为队头。它是一种特殊的线性表，特殊之处在于它只允许在表的前端进行删除操作，而在表的后端进行插入操作，和栈一样，队列是一种操作受限制的线性表。</span><br><span class="line"></span><br><span class="line">队列是一种先进先出的数据结构，又称为先进先出的线性表，简称 FIFO（First In First Out）结构。也就是说先放的先取，后放的后取，就如同行李过安检的时候，先放进去的行李在另一端总是先出来，后放入的行李会在最后面出来。</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="11-什么是多态-什么是分类-什么是协议"><a href="#11-什么是多态-什么是分类-什么是协议" class="headerlink" title="11. 什么是多态? 什么是分类? 什么是协议?"></a>11. 什么是多态? 什么是分类? 什么是协议?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">多态在面向对象语言中指同一个接口有多种不同的实现方式,在OC中,多态则是不同对象对同一消息的不同响应方式;子类通过重写父类的方法来改变同一方法的实现.体现多态性</span><br><span class="line">通俗来讲: 多态就父类类型的指针指向子类的对象,在函数（方法）调用的时候可以调用到正确版本的函数（方法）。</span><br><span class="line">多态就是某一类事物的多种形态.继承是多态的前提;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">分类: 在不修改原有类代码的情况下,可以给类添加方法</span><br><span class="line">Categroy 给类扩展方法,或者关联属性, Categroy底层结构也是一个结构体:内部存储这结构体的名字,那个类的分类,以及对象和类方法列表,协议,属性信息</span><br><span class="line">通过Runtime加载某个类的所有Category数据</span><br><span class="line">把所有Category的方法、属性、协议数据，合并到一个大数组中后面参与编译的Category数据，会在数组的前面</span><br><span class="line">将合并后的分类数据（方法、属性、协议），插入到类原来数据的前面</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">协议：协议是一套标准，这个标准中声明了很多方法，但是不关心具体这些方法是怎么实现的，具体实现是由遵循这个协议的类去完成的。</span><br><span class="line">在OC中，一个类可以实现多个协议，通过协议可以弥补单继承的缺陷但是协议跟继承不一样，协议只是一个方法列表，方法的实现得靠遵循这个协议的类去实现。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="12-UIView-和-CALayer-是什么关系？"><a href="#12-UIView-和-CALayer-是什么关系？" class="headerlink" title="12.UIView 和 CALayer 是什么关系？"></a>12.UIView 和 CALayer 是什么关系？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">UIView 继承 UIResponder，而 UIResponder 是响应者对象，可以对iOS 中的事件响应及传递，CALayer 没有继承自 UIResponder，所以 CALayer 不具备响应处理事件的能力。CALayer 是 QuartzCore 中的类，是一个比较底层的用来绘制内容的类，用来绘制UI</span><br><span class="line"></span><br><span class="line">UIView 对 CALayer 封装属性，对 UIView 设置 frame、center、bounds 等位置信息时，其实都是UIView 对 CALayer 进一层封装，使得我们可以很方便地设置控件的位置；例如圆角、阴影等属性， UIView 就没有进一步封装，所以我们还是需要去设置 Layer 的属性来实现功能。</span><br><span class="line"></span><br><span class="line">UIView 是 CALayer 的代理，UIView 持有一个 CALayer 的属性，并且是该属性的代理，用来提供一些 CALayer 行的数据，例如动画和绘制。</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="13-说一下-JS-和-OC-互相调用的几种方式？"><a href="#13-说一下-JS-和-OC-互相调用的几种方式？" class="headerlink" title="13. 说一下 JS 和 OC 互相调用的几种方式？"></a>13. 说一下 JS 和 OC 互相调用的几种方式？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">js调用oc的三种方式:</span><br><span class="line"></span><br><span class="line">方式一:通过替换js中的function(方法)</span><br><span class="line">方式二:通过注入对象,直接调用对象方法</span><br><span class="line">方式三:利用网页重定向,截取字符串.</span><br><span class="line"></span><br><span class="line">oc调用js代码两种方式</span><br><span class="line"></span><br><span class="line">1.通过webVIew调用 webView stringByEvaluatingJavaScriptFromString: 调用</span><br><span class="line">2.通过JSContext调用[context evaluateScript:];</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="14-如何理解-HTTP-Http-和-Https-的区别？Https-为什么更加安全？"><a href="#14-如何理解-HTTP-Http-和-Https-的区别？Https-为什么更加安全？" class="headerlink" title="14. 如何理解 HTTP?/Http 和 Https 的区别？Https 为什么更加安全？"></a>14. 如何理解 HTTP?/Http 和 Https 的区别？Https 为什么更加安全？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">HTTP本质上是一种协议，全称是Hypertext Transfer Protocol，即超文本传输协议。HTTP是一个基于TCP&#x2F;IP通信协议来传递数据, 该协议用于规定客户端与服务端之间的传输规则，所传输的内容不局限于文本(其实可以传输任意类型的数据)。</span><br><span class="line"></span><br><span class="line">一次HTTP可以看做是一个事务,其工作过程分为4步:</span><br><span class="line"></span><br><span class="line">1.客户端与服务器建立连接</span><br><span class="line">2.建立连接后,客户端给服务端发送请求</span><br><span class="line">3.服务器收到消息后,给与响应操作</span><br><span class="line">4.客户端收到消息后,展示到屏幕上,断开连接.</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">区别</span><br><span class="line"></span><br><span class="line">1.HTTPS 需要向机构申请 CA 证书，极少免费。</span><br><span class="line"></span><br><span class="line">2.HTTP 属于明文传输，HTTPS基于 SSL 进行加密传输。</span><br><span class="line"></span><br><span class="line">3.HTTP 端口号为 80，HTTPS 端口号为 443 。</span><br><span class="line"></span><br><span class="line">4.HTTPS 是加密传输，有身份验证的环节，更加安全。</span><br><span class="line"></span><br><span class="line">安全</span><br><span class="line"></span><br><span class="line">SSL(安全套接层) TLS(传输层安全)</span><br><span class="line"></span><br><span class="line">以上两者在传输层之上，对网络连接进行加密处理，保障数据的完整性，更加的安全。</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="15-编程中的六大设计原则？"><a href="#15-编程中的六大设计原则？" class="headerlink" title="15. 编程中的六大设计原则？"></a>15. 编程中的六大设计原则？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">1.单一职责原则</span><br><span class="line"></span><br><span class="line">通俗地讲就是一个类只做一件事</span><br><span class="line"></span><br><span class="line">CALayer：动画和视图的显示。</span><br><span class="line"></span><br><span class="line">UIView：只负责事件传递、事件响应。</span><br><span class="line"></span><br><span class="line">2.开闭原则</span><br><span class="line"></span><br><span class="line">对修改关闭，对扩展开放。 要考虑到后续的扩展性，而不是在原有的基础上来回修改</span><br><span class="line"></span><br><span class="line">3.接口隔离原则</span><br><span class="line"></span><br><span class="line">使用多个专门的协议、而不是一个庞大臃肿的协议，如 UITableviewDelegate + UITableViewDataSource</span><br><span class="line"></span><br><span class="line">4.依赖倒置原则</span><br><span class="line"></span><br><span class="line">抽象不应该依赖于具体实现、具体实现可以依赖于抽象。 调用接口感觉不到内部是如何操作的</span><br><span class="line"></span><br><span class="line">5.里氏替换原则</span><br><span class="line"></span><br><span class="line">父类可以被子类无缝替换，且原有的功能不受任何影响 如：KVO</span><br><span class="line"></span><br><span class="line">6.迪米特法则</span><br><span class="line"></span><br><span class="line">一个对象应当对其他对象尽可能少的了解，实现高聚合、低耦合</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="16-Objective-C-与-Swift-的异同？"><a href="#16-Objective-C-与-Swift-的异同？" class="headerlink" title="16.Objective-C 与 Swift 的异同？"></a>16.Objective-C 与 Swift 的异同？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">1.1、swift和OC的共同点：</span><br><span class="line"></span><br><span class="line"> - OC出现过的绝大多数概念，比如引用计数、ARC（自动引用计数）、属性、协议、接口、初始化、扩展类、命名参数、匿名函数等，在Swift中继续有效（可能最多换个术语）。</span><br><span class="line"></span><br><span class="line"> - Swift和Objective-C共用一套运行时环境，Swift的类型可以桥接到Objective-C（下面我简称OC），反之亦然</span><br><span class="line"></span><br><span class="line">1.2、swift的优点：</span><br><span class="line"></span><br><span class="line"> - swift注重安全，OC注重灵活</span><br><span class="line"></span><br><span class="line"> - swift注重面向协议编程、函数式编程、面向对象编程，OC注重面向对象编程</span><br><span class="line"></span><br><span class="line"> - swift注重值类型，OC注重指针和引用</span><br><span class="line"></span><br><span class="line"> - swift是静态类型语言，OC是动态类型语言</span><br><span class="line"></span><br><span class="line"> - swift容易阅读，文件结构和大部分语法简易化，只有.swift文件，结尾不需要分号</span><br><span class="line"></span><br><span class="line"> - swift中的可选类型，是用于所有数据类型，而不仅仅局限于类。相比于OC中的nil更加安全和简明</span><br><span class="line"></span><br><span class="line"> - swift中的泛型类型更加方便和通用，而非OC中只能为集合类型添加泛型</span><br><span class="line"></span><br><span class="line"> - swift中各种方便快捷的高阶函数（函数式编程） (Swift的标准数组支持三个高阶函数：map，filter和reduce,以及map的扩展flatMap)</span><br><span class="line"></span><br><span class="line"> - swift新增了两种权限，细化权限。open &gt; public &gt; internal(默认) &gt; fileprivate &gt; private</span><br><span class="line"></span><br><span class="line"> - swift中独有的元组类型(tuples)，把多个值组合成复合值。元组内的值可以是任何类型，并不要求是相同类型的。</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="17-沙盒目录结构是怎样的？各自用于那些场景？"><a href="#17-沙盒目录结构是怎样的？各自用于那些场景？" class="headerlink" title="17. 沙盒目录结构是怎样的？各自用于那些场景？"></a>17. 沙盒目录结构是怎样的？各自用于那些场景？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">Application：存放程序源文件，上架前经过数字签名，上架后不可修改</span><br><span class="line">Documents：常用目录，iCloud备份目录，存放数据</span><br><span class="line">Library</span><br><span class="line">Caches：存放体积大又不需要备份的数据</span><br><span class="line">Preference：设置目录，iCloud会备份设置信息</span><br><span class="line">tmp：存放临时文件，不会被备份，而且这个文件下的数据有可能随时被清除的可能</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="17-iOS-中数据持久化方案有哪些？"><a href="#17-iOS-中数据持久化方案有哪些？" class="headerlink" title="17.iOS 中数据持久化方案有哪些？"></a>17.iOS 中数据持久化方案有哪些？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">NSUserDefault 简单数据快速读写</span><br><span class="line">Property list (属性列表)文件存储</span><br><span class="line">Archiver (归档)</span><br><span class="line">SQLite 本地数据库</span><br><span class="line">CoreData（是iOS5之后才出现的一个框架，本质上是对SQLite的一个封装，它提供了对象-关系映射(ORM)的功能，即能够将OC对象转化成数据，保存在SQLite数据库文件中，也能够将保存在数据库中的数据还原成OC对象，通过CoreData管理应用程序的数据模型）</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="18-单个-viewController-的生命周期？"><a href="#18-单个-viewController-的生命周期？" class="headerlink" title="18. 单个 viewController 的生命周期？"></a>18. 单个 viewController 的生命周期？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">- initWithCoder:(NSCoder *)aDecoder：（如果使用storyboard或者xib）</span><br><span class="line">- loadView：加载view</span><br><span class="line">- viewDidLoad：view加载完毕</span><br><span class="line">- viewWillAppear：控制器的view将要显示</span><br><span class="line">- viewWillLayoutSubviews：控制器的view将要布局子控件</span><br><span class="line">- viewDidLayoutSubviews：控制器的view布局子控件完成  </span><br><span class="line">- viewDidAppear:控制器的view完全显示</span><br><span class="line">- viewWillDisappear：控制器的view即将消失的时候</span><br><span class="line">- viewDidDisappear：控制器的view完全消失的时候</span><br><span class="line">- dealloc 控制器销毁</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="19-cocoa-和-cocoa-touch-是什么-cocoa-touch-底层技术架构"><a href="#19-cocoa-和-cocoa-touch-是什么-cocoa-touch-底层技术架构" class="headerlink" title="19.cocoa 和 cocoa touch 是什么?/cocoa touch 底层技术架构?"></a>19.cocoa 和 cocoa touch 是什么?/cocoa touch 底层技术架构?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">Cocoa包含Foundation和AppKit框架，可用于开发Mac OS X系统的应用程序。</span><br><span class="line">Cocoa Touch包含Foundation和UIKit框架，可用于开发iPhone OS系统的应用程序。</span><br><span class="line">Cocoa是 Mac OS X 的开发环境，Cocoa Touch是 iPhone OS的开发环境。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">cocoa touch底层技术架构 主要分为4层:</span><br><span class="line"></span><br><span class="line">可触摸层 Cocoa Touch : UI组件,触摸事件和事件驱动,系统接口</span><br><span class="line">媒体层 Media: 音视频播放,动画,2D和3D图形</span><br><span class="line">Core Server: 核心服务层,底层特性,文件,网络,位置服务区等</span><br><span class="line">Core OS: 内存管理,底层网络,硬盘管理</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="20-如何选择-delegate、notification、KVO？"><a href="#20-如何选择-delegate、notification、KVO？" class="headerlink" title="20. 如何选择 delegate、notification、KVO？"></a>20. 如何选择 delegate、notification、KVO？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">三种模式都是一个对象传递事件给另外一个对象，并且不要他们有耦合。</span><br><span class="line"></span><br><span class="line">delegate. 一对一</span><br><span class="line">notification 一对多,多对多</span><br><span class="line">KVO 一对一</span><br><span class="line">三者各有自己的特点:</span><br><span class="line"></span><br><span class="line">delegate 语法简洁,方便阅读,易于调试</span><br><span class="line">notification 灵活多变,可以跨越多个类之间进行使用</span><br><span class="line">KVO 实现属性监听,实现model和view同步</span><br><span class="line">可以根据实际开发遇到的场景来使用不同的方式</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="21-平时开发有没有玩过-Instrument-？"><a href="#21-平时开发有没有玩过-Instrument-？" class="headerlink" title="21. 平时开发有没有玩过 Instrument ？"></a>21. 平时开发有没有玩过 Instrument ？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">Instruments里面工具很多，常用的有：</span><br><span class="line">(1).Time Profiler：性能分析,用来检测应用CPU的使用情况.可以看到应用程序中各个方法正在消耗CPU时间。</span><br><span class="line">(2).Zoombies：检查是否访问了僵尸对象，但是这个工具只能从上往下检查，不智能</span><br><span class="line">(3).Allocations：用来检查内存，写算法的那批人也用这个来检查</span><br><span class="line">(4).Leaks：检查内存，看是否有内存泄漏</span><br><span class="line">(5).Core Animation：评估图形性能，这个选项检查了图片是否被缩放，以及像素是否对齐。被放缩的图片会被标记为黄色，像素不对齐则会标注为紫色。黄色、紫色越多，性能越差。</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="常用的排序算法"><a href="#常用的排序算法" class="headerlink" title="常用的排序算法"></a>常用的排序算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">选择排序、冒泡排序、插入排序三种排序算法可以总结为如下：</span><br><span class="line"></span><br><span class="line">都将数组分为已排序部分和未排序部分。</span><br><span class="line"></span><br><span class="line">选择排序将已排序部分定义在左端，然后选择未排序部分的最小元素和未排序部分的第一个元素交换。</span><br><span class="line"></span><br><span class="line">冒泡排序将已排序部分定义在右端，在遍历未排序部分的过程执行交换，将最大元素交换到最右端。</span><br><span class="line"></span><br><span class="line">插入排序将已排序部分定义在左端，将未排序部分元的第一个元素插入到已排序部分合适的位置。</span><br><span class="line"></span><br><span class="line">&#x2F;** </span><br><span class="line"> *  【选择排序】：最值出现在起始端</span><br><span class="line"> *  </span><br><span class="line"> *  第1趟：在n个数中找到最小(大)数与第一个数交换位置</span><br><span class="line"> *  第2趟：在剩下n-1个数中找到最小(大)数与第二个数交换位置</span><br><span class="line"> *  重复这样的操作...依次与第三个、第四个...数交换位置</span><br><span class="line"> *  第n-1趟，最终可实现数据的升序（降序）排列。</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">void selectSort(int *arr, int length) &#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; length - 1; i++) &#123; &#x2F;&#x2F;趟数</span><br><span class="line">        for (int j &#x3D; i + 1; j &lt; length; j++) &#123; &#x2F;&#x2F;比较次数</span><br><span class="line">            if (arr[i] &gt; arr[j]) &#123;</span><br><span class="line">                int temp &#x3D; arr[i];</span><br><span class="line">                arr[i] &#x3D; arr[j];</span><br><span class="line">                arr[j] &#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;** </span><br><span class="line"> *  【冒泡排序】：相邻元素两两比较，比较完一趟，最值出现在末尾</span><br><span class="line"> *  第1趟：依次比较相邻的两个数，不断交换（小数放前，大数放后）逐个推进，最值最后出现在第n个元素位置</span><br><span class="line"> *  第2趟：依次比较相邻的两个数，不断交换（小数放前，大数放后）逐个推进，最值最后出现在第n-1个元素位置</span><br><span class="line"> *   ……   ……</span><br><span class="line"> *  第n-1趟：依次比较相邻的两个数，不断交换（小数放前，大数放后）逐个推进，最值最后出现在第2个元素位置 </span><br><span class="line"> *&#x2F;</span><br><span class="line">void bublleSort(int *arr, int length) &#123;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; length - 1; i++) &#123; &#x2F;&#x2F;趟数</span><br><span class="line">        for(int j &#x3D; 0; j &lt; length - i - 1; j++) &#123; &#x2F;&#x2F;比较次数</span><br><span class="line">            if(arr[j] &gt; arr[j+1]) &#123;</span><br><span class="line">                int temp &#x3D; arr[j];</span><br><span class="line">                arr[j] &#x3D; arr[j+1];</span><br><span class="line">                arr[j+1] &#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  折半查找：优化查找时间（不用遍历全部数据）</span><br><span class="line"> *</span><br><span class="line"> *  折半查找的原理：</span><br><span class="line"> *   1&gt; 数组必须是有序的</span><br><span class="line"> *   2&gt; 必须已知min和max（知道范围）</span><br><span class="line"> *   3&gt; 动态计算mid的值，取出mid对应的值进行比较</span><br><span class="line"> *   4&gt; 如果mid对应的值大于要查找的值，那么max要变小为mid-1</span><br><span class="line"> *   5&gt; 如果mid对应的值小于要查找的值，那么min要变大为mid+1</span><br><span class="line"> *</span><br><span class="line"> *&#x2F; </span><br><span class="line">&#x2F;&#x2F; 已知一个有序数组, 和一个key, 要求从数组中找到key对应的索引位置 </span><br><span class="line">int findKey(int *arr, int length, int key) &#123;</span><br><span class="line">    int min &#x3D; 0, max &#x3D; length - 1, mid;</span><br><span class="line">    while (min &lt;&#x3D; max) &#123;</span><br><span class="line">        mid &#x3D; (min + max) &#x2F; 2; &#x2F;&#x2F;计算中间值</span><br><span class="line">        if (key &gt; arr[mid]) &#123;</span><br><span class="line">            min &#x3D; mid + 1;</span><br><span class="line">        &#125; else if (key &lt; arr[mid]) &#123;</span><br><span class="line">            max &#x3D; mid - 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="SDWebImage-加载图片过程"><a href="#SDWebImage-加载图片过程" class="headerlink" title="SDWebImage 加载图片过程"></a>SDWebImage 加载图片过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">0、首先显示占位图</span><br><span class="line"></span><br><span class="line">1、在webimagecache中寻找图片对应的缓存，它是以url为数据索引先在内存中查找是否有缓存；</span><br><span class="line"></span><br><span class="line">2、如果没有缓存，就通过md5处理过的key来在磁盘中查找对应的数据，如果找到就会把磁盘中的数据加到内存中，并显示出来；</span><br><span class="line"></span><br><span class="line">3、如果内存和磁盘中都没有找到，就会向远程服务器发送请求，开始下载图片；</span><br><span class="line"></span><br><span class="line">4、下载完的图片加入缓存中，并写入到磁盘中；</span><br><span class="line"></span><br><span class="line">5、整个获取图片的过程是在子线程中进行，在主线程中显示。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="AFNetworking-底层原理分析"><a href="#AFNetworking-底层原理分析" class="headerlink" title="AFNetworking 底层原理分析"></a>AFNetworking 底层原理分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">AFNetworking是封装的NSURLSession的网络请求，由五个模块组成：分别由NSURLSession,Security,Reachability,Serialization,UIKit五部分组成</span><br><span class="line"></span><br><span class="line">NSURLSession：网络通信模块（核心模块） 对应 AFNetworking中的 AFURLSessionManager和对HTTP协议进行特化处理的AFHTTPSessionManager,AFHTTPSessionManager是继承于AFURLSessionmanager的</span><br><span class="line"></span><br><span class="line">Security：网络通讯安全策略模块  对应 AFSecurityPolicy</span><br><span class="line"></span><br><span class="line">Reachability：网络状态监听模块 对应AFNetworkReachabilityManager</span><br><span class="line"></span><br><span class="line">Seriaalization：网络通信信息序列化、反序列化模块 对应 AFURLResponseSerialization</span><br><span class="line"></span><br><span class="line">UIKit：对于iOS UIKit的扩展库</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h2 id="进阶题："><a href="#进阶题：" class="headerlink" title="进阶题："></a>进阶题：</h2><h3 id="1-KVC-的底层实现？"><a href="#1-KVC-的底层实现？" class="headerlink" title="1.KVC 的底层实现？"></a>1.KVC 的底层实现？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">当一个对象调用setValue方法时，方法内部会做以下操作：</span><br><span class="line">1). 检查是否存在相应的key的set方法，如果存在，就调用set方法。</span><br><span class="line">2). 如果set方法不存在，就会查找与key相同名称并且带下划线的成员变量，如果有，则直接给成员变量属性赋值。</span><br><span class="line">3). 如果没有找到_key，就会查找相同名称的属性key，如果有就直接赋值。</span><br><span class="line">4). 如果还没有找到，则调用valueForUndefinedKey:和setValue:forUndefinedKey:方法。</span><br><span class="line">这些方法的默认实现都是抛出异常，我们可以根据需要重写它们。</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="2-KVO-的底层实现？"><a href="#2-KVO-的底层实现？" class="headerlink" title="2.KVO 的底层实现？"></a>2.KVO 的底层实现？</h3><p>[图片上传中…(image-2fb5e1-1588225047037-0)]</p>
<figcaption></figcaption>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line"></span><br><span class="line">KVO-键值观察机制，原理如下：</span><br><span class="line"></span><br><span class="line">1.当给A类添加KVO的时候，runtime动态的生成了一个子类NSKVONotifying_A，让A类的isa指针指向NSKVONotifying_A类，重写class方法，隐藏对象真实类信息</span><br><span class="line"></span><br><span class="line">2.重写监听属性的setter方法，在setter方法内部调用了Foundation 的 _NSSetObjectValueAndNotify 函数</span><br><span class="line"></span><br><span class="line">3._NSSetObjectValueAndNotify函数内部</span><br><span class="line"></span><br><span class="line">a) 首先会调用 willChangeValueForKey</span><br><span class="line"></span><br><span class="line">b) 然后给属性赋值</span><br><span class="line"></span><br><span class="line">c) 最后调用 didChangeValueForKey</span><br><span class="line"></span><br><span class="line">d) 最后调用 observer 的 observeValueForKeyPath 去告诉监听器属性值发生了改变 .</span><br><span class="line"></span><br><span class="line">4.重写了dealloc做一些 KVO 内存释放</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="3-说一下工作中你怎么做性能优化的"><a href="#3-说一下工作中你怎么做性能优化的" class="headerlink" title="3. 说一下工作中你怎么做性能优化的"></a>3. 说一下工作中你怎么做性能优化的</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">答：一般都是说关于tableView的优化处理，</span><br><span class="line"></span><br><span class="line">造成tableView卡顿的原因</span><br><span class="line">1.没有使用cell的重用标识符，导致一直创建新的cell</span><br><span class="line">2.cell的重新布局</span><br><span class="line">3.没有提前计算并缓存cell的属性及内容</span><br><span class="line">4.cell中控件的数量过多</span><br><span class="line">5.使用了ClearColor，无背景色，透明度为0</span><br><span class="line">6.更新只使用tableView.reloadData()（如果只是更新某组的话，使用reloadSection进行局部更新）</span><br><span class="line">7.加载网络数据，下载图片，没有使用异步加载，并缓存</span><br><span class="line">8.使用addView 给cell动态添加view</span><br><span class="line">9.没有按需加载cell（cell滚动很快时，只加载范围内的cell）</span><br><span class="line">10.实现无用的代理方法(tableView只遵守两个协议)</span><br><span class="line">11.没有做缓存行高（estimatedHeightForRow不能和HeightForRow里面的layoutIfNeed同时存在，这两者同时存在才会出现“窜动”的bug。</span><br><span class="line">建议是：只要是固定行高就写预估行高来减少行高调用次数提升性能。如果是动态行高就不要写预估方法了，用一个行高的缓存字典来减少代码的调用次数即可）</span><br><span class="line">12.做了多余的绘制工作（在实现drawRect:的时候，它的rect参数就是需要绘制的区域，这个区域之外的不需要进行绘制）</span><br><span class="line">13.没有预渲染图像。（当新的图像出现时，仍然会有短暂的停顿现象。解决的办法就是在bitmap context里先将其画一遍，导出成UIImage对象，然后再绘制到屏幕）</span><br><span class="line"></span><br><span class="line">提升tableView的流畅度</span><br><span class="line">*本质上是降低 CPU、GPU 的工作，从这两个大的方面去提升性能。</span><br><span class="line">  1.CPU：对象的创建和销毁、对象属性的调整、布局计算、文本的计算和排版、图片的格式转换和解码、图像的绘制</span><br><span class="line">  2.GPU：纹理的渲染</span><br><span class="line"></span><br><span class="line">卡顿优化在 CPU 层面</span><br><span class="line">1.尽量用轻量级的对象，比如用不到事件处理的地方，可以考虑使用 CALayer 取代 UIView</span><br><span class="line">2.不要频繁地调用 UIView 的相关属性，比如 frame、bounds、transform 等属性，尽量减少不必要的修改</span><br><span class="line">3.尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性</span><br><span class="line">4.Autolayout 会比直接设置 frame 消耗更多的 CPU 资源</span><br><span class="line">5.图片的 size 最好刚好跟 UIImageView 的 size 保持一致</span><br><span class="line">6.控制一下线程的最大并发数量</span><br><span class="line">7.尽量把耗时的操作放到子线程</span><br><span class="line">8.文本处理（尺寸计算、绘制）</span><br><span class="line">9.图片处理（解码、绘制）</span><br><span class="line"></span><br><span class="line">卡顿优化在 GPU层面</span><br><span class="line">1.尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示</span><br><span class="line">2.GPU能处理的最大纹理尺寸是 4096x4096，一旦超过这个尺寸，就会占用 CPU 资源进行处理，所以纹理尽量不要超过这个尺寸</span><br><span class="line">3.尽量减少视图数量和层次</span><br><span class="line">4.减少透明的视图（alpha&lt;1），不透明的就设置 opaque 为 YES</span><br><span class="line">5.尽量避免出现离屏渲染</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/">iOS 保持界面流畅的技巧</a></p>
<h3 id="5-Runtime-实现的机制是什么？能做什么事情呢？"><a href="#5-Runtime-实现的机制是什么？能做什么事情呢？" class="headerlink" title="5.Runtime 实现的机制是什么？能做什么事情呢？"></a>5.Runtime 实现的机制是什么？能做什么事情呢？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">runtime简称运行时。OC是运行时机制，也就是在运行时才做一些处理。例如：C语言在编译的时候就知道要调用哪个方法函数，而OC在编译的时候并不知道要调用哪个方法函数，只有在运行的时候才知道调用的方法函数名称，来找到对应的方法函数进行调用。</span><br><span class="line"></span><br><span class="line">1.发送消息</span><br><span class="line">【场景：方法调用】</span><br><span class="line"></span><br><span class="line">2.交换方法实现（交换系统的方法）</span><br><span class="line">【场景：当第三方框架或者系统原生方法功能不能满足我们的时候，我们可以在保持系统原有方法功能的基础上，添加额外的功能。】</span><br><span class="line"></span><br><span class="line">3.动态添加方法</span><br><span class="line">【场景：如果一个类方法非常多，加载类到内存的时候也比较耗费资源，需要给每个方法生成映射表，可以使用动态给某个类，添加方法解决。】</span><br><span class="line"></span><br><span class="line">4.利用关联对象（AssociatedObject）给分类添加属性</span><br><span class="line">【</span><br><span class="line"> 场景：分类是不能自定义属性和变量的，这时候可以使用runtime动态添加属性方法；</span><br><span class="line"> 原理：给一个类声明属性，其实本质就是给这个类添加关联，并不是直接把这个值的内存空间添加到类存空间。</span><br><span class="line"> 】</span><br><span class="line"></span><br><span class="line">5.遍历类的所有成员变量</span><br><span class="line">【</span><br><span class="line">  1.NSCoding自动归档解档</span><br><span class="line">  场景：如果一个模型有许多个属性，实现自定义模型数据持久化时，需要对每个属性都实现一遍encodeObject 和 decodeObjectForKey方法，比较麻烦。我们可以使用Runtime来解决。</span><br><span class="line">  原理：用runtime提供的函数遍历Model自身所有属性，并对属性进行encode和decode操作。</span><br><span class="line"></span><br><span class="line">  2.字典转模型</span><br><span class="line">  原理：利用Runtime，遍历模型中所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值。</span><br><span class="line"></span><br><span class="line">  3.修改textfield的占位文字颜色</span><br><span class="line">】</span><br><span class="line"></span><br><span class="line">6.利用消息转发机制解决方法找不到的异常问题</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6fd68ac84701">教你深刻理解 Runtime 机制</a></p>
<p><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://juejin.im/post/5cb5c03f51882533017e7a70%23heading-5">Runtime 在工作中的运用</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1f43dd215159">Runtime 运行机制</a></p>
<h3 id="6-iOS-图片设置圆角性能问题"><a href="#6-iOS-图片设置圆角性能问题" class="headerlink" title="6.iOS 图片设置圆角性能问题"></a>6.iOS 图片设置圆角性能问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">1.直接使用setCornerRadius</span><br><span class="line">【这样设置会触发离屏渲染，比较消耗性能。比如当一个页面上有十几头像这样设置了圆角会明显感觉到卡顿。</span><br><span class="line"> 注意：png图片UIImageView处理圆角是不会产生离屏渲染的。（ios9.0之后不会离屏渲染，ios9.0之前还是会离屏渲染）</span><br><span class="line"> 】</span><br><span class="line"></span><br><span class="line"> 2.setCornerRadius设置圆角之后，shouldRasterize&#x3D;YES光栅化</span><br><span class="line"> 【avatarImageView.layer.shouldRasterize &#x3D; YES;</span><br><span class="line">   avatarImageViewUrl.layer.rasterizationScale&#x3D;[UIScreen mainScreen].scale;  &#x2F;&#x2F;UIImageView不加这句会产生一点模糊</span><br><span class="line"></span><br><span class="line">  shouldRasterize&#x3D;YES设置光栅化，可以使离屏渲染的结果缓存到内存中存为位图，</span><br><span class="line">使用的时候直接使用缓存，节省了一直离屏渲染损耗的性能。</span><br><span class="line"></span><br><span class="line">  但是如果layer及sublayers常常改变的话，它就会一直不停的渲染及删除缓存重新</span><br><span class="line">创建缓存，所以这种情况下建议不要使用光栅化，这样也是比较损耗性能的。</span><br><span class="line"> 】</span><br><span class="line"></span><br><span class="line"> 3.直接覆盖一张中间为圆形透明的图片（推荐使用）</span><br><span class="line"></span><br><span class="line"> 4.UIImage drawInRect绘制圆角</span><br><span class="line">【这种方式GPU损耗低内存占用大，而且UIButton上不知道怎么绘制，可以用</span><br><span class="line">UIimageView添加个点击手势当做UIButton使用。】</span><br><span class="line"></span><br><span class="line">5.SDWebImage处理图片时Core Graphics绘制圆角（暂时感觉是最优方法)</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/34189f62bfd8">iOS 图片设置圆角性能问题</a></p>
<h3 id="7-什么是-RunLoop？"><a href="#7-什么是-RunLoop？" class="headerlink" title="7. 什么是 RunLoop？"></a>7. 什么是 RunLoop？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">从字面上讲就是运行循环，它内部就是do-while循环，在这个循环内部不断地处理各种任务。</span><br><span class="line">一个线程对应一个RunLoop，基本作用就是保持程序的持续运行，处理app中的各种事件。通过runloop，有事运行，没事就休息，可以节省cpu资源，提高程序性能。</span><br><span class="line">主线程的run loop默认是启动的。iOS的应用程序里面，程序启动后会有一个如下的main()函数</span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">RunLoop，是多线程的法宝，即一个线程一次只能执行一个任务，执行完任务后就会退出线程。主线程执行完即时任务时会继续等待接收事件而不退出。非主线程通常来说就是为了执行某一任务的，执行完毕就需要归还资源，因此默认是不运行RunLoop的；</span><br><span class="line"></span><br><span class="line">每一个线程都有其对应的RunLoop，只是默认只有主线程的RunLoop是启动的，其它子线程的RunLoop默认是不启动的，若要启动则需要手动启动；</span><br><span class="line"></span><br><span class="line">在一个单独的线程中，如果需要在处理完某个任务后不退出，继续等待接收事件，则需要启用RunLoop；</span><br><span class="line"></span><br><span class="line">NSRunLoop提供了一个添加NSTimer的方法，可以指定Mode，如果要让任何情况下都回调，则需要设置Mode为Common模式；</span><br><span class="line"></span><br><span class="line">实质上，对于子线程的runloop默认是不存在的，因为苹果采用了懒加载的方式。如果我们没有手动调用[NSRunLoop currentRunLoop]的话，就不会去查询是否存在当前线程的RunLoop，也就不会去加载，更不会创建。</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://blog.ibireme.com/2015/05/18/runloop/">深入理解 RunLoop</a></p>
<h3 id="8-以-scheduledTimerWithTimeInterval-的方式触发的-timer，在滑动页面上的列表时，timer-会暂停，为什么？该如何解决？"><a href="#8-以-scheduledTimerWithTimeInterval-的方式触发的-timer，在滑动页面上的列表时，timer-会暂停，为什么？该如何解决？" class="headerlink" title="8. 以 scheduledTimerWithTimeInterval 的方式触发的 timer，在滑动页面上的列表时，timer 会暂停，为什么？该如何解决？"></a>8. 以 scheduledTimerWithTimeInterval 的方式触发的 timer，在滑动页面上的列表时，timer 会暂停，为什么？该如何解决？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">原因在于滑动时当前线程的runloop切换了mode用于列表滑动，导致timer暂停。</span><br><span class="line">runloop中的mode主要用来指定事件在runloop中的优先级，有以下几种：</span><br><span class="line">* Default（NSDefaultRunLoopMode）：默认，一般情况下使用；</span><br><span class="line">* Connection（NSConnectionReplyMode）：一般系统用来处理NSConnection相关事件，开发者一般用不到；</span><br><span class="line">* Modal（NSModalPanelRunLoopMode）：处理modal panels事件；</span><br><span class="line">* Event Tracking（NSEventTrackingRunLoopMode）：用于处理拖拽和用户交互的模式。</span><br><span class="line">* Common（NSRunloopCommonModes）：模式合集。默认包括Default，Modal，Event Tracking三大模式，可以处理几乎所有事件。</span><br><span class="line">回到题中的情境。滑动列表时，runloop的mode由原来的Default模式切换到了Event Tracking模式，timer原来好好的运行在Default模式中，被关闭后自然就停止工作了。</span><br><span class="line">解决方法其一是将timer加入到NSRunloopCommonModes中。其二是将timer放到另一个线程中，然后开启另一个线程的runloop，这样可以保证与主线程互不干扰，而现在主线程正在处理页面滑动。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">方法1</span><br><span class="line">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</span><br><span class="line">方法2</span><br><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">timer &#x3D; [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(repeat:) userInfo:nil repeats:true];</span><br><span class="line">[[NSRunLoop currentRunLoop] run];</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="9-进程与线程"><a href="#9-进程与线程" class="headerlink" title="9. 进程与线程"></a>9. 进程与线程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">进程：</span><br><span class="line"></span><br><span class="line">1.进程是一个具有一定独立功能的程序关于某次数据集合的一次运行活动，它是操作系统分配资源的基本单元.</span><br><span class="line"></span><br><span class="line">2.进程是指在系统中正在运行的一个应用程序，就是一段程序的执行过程,我们可以理解为手机上的一个app.</span><br><span class="line"></span><br><span class="line">3.每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内，拥有独立运行所需的全部资源</span><br><span class="line"></span><br><span class="line">线程</span><br><span class="line"></span><br><span class="line">1.程序执行流的最小单元，线程是进程中的一个实体.</span><br><span class="line"></span><br><span class="line">2.一个进程要想执行任务,必须至少有一条线程.应用程序启动的时候，系统会默认开启一条线程,也就是主线程</span><br><span class="line"></span><br><span class="line">进程和线程的关系</span><br><span class="line"></span><br><span class="line">1.线程是进程的执行单元，进程的所有任务都在线程中执行</span><br><span class="line"></span><br><span class="line">2.线程是 CPU 分配资源和调度的最小单位</span><br><span class="line"></span><br><span class="line">3.一个程序可以对应多个进程(多进程),一个进程中可有多个线程,但至少要有一条线程</span><br><span class="line"></span><br><span class="line">4.同一个进程内的线程共享进程资源</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="10-iOS-中实现多线程的几种方案，各自有什么特点？讲一下具体使用场景-在项目什么时候选择使用-GCD，什么时候选-择-NSOperation"><a href="#10-iOS-中实现多线程的几种方案，各自有什么特点？讲一下具体使用场景-在项目什么时候选择使用-GCD，什么时候选-择-NSOperation" class="headerlink" title="10.iOS 中实现多线程的几种方案，各自有什么特点？讲一下具体使用场景 / 在项目什么时候选择使用 GCD，什么时候选 择 NSOperation?"></a>10.iOS 中实现多线程的几种方案，各自有什么特点？讲一下具体使用场景 / 在项目什么时候选择使用 GCD，什么时候选 择 NSOperation?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">NSThread 面向对象的，需要程序员手动创建线程，但不需要手动销毁。子线程间通信很难。</span><br><span class="line"></span><br><span class="line">GCD c语言，充分利用了设备的多核，自动管理线程生命周期。比NSOperation效率更高。</span><br><span class="line"></span><br><span class="line">NSOperation 基于gcd封装，更加面向对象，比gcd多了一些功能。</span><br><span class="line"></span><br><span class="line">【场景：1.多个网络请求完成后执行下一步 2.多个网络请求顺序执行后执行下一步 3.异步操作两组数据时, 执行完第一组之后, 才能执行第二组】</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">项目中使用 NSOperation 的优点是 NSOperation 是对线程的高度抽象，在项目中使 用它，会使项目的程序结构更好，子类化 NSOperation 的设计思路，是具有面向对 象的优点(复用、封装)，使得实现是多线程支持，而接口简单，建议在复杂项目中 使用。</span><br><span class="line"></span><br><span class="line">项目中使用 GCD 的优点是 GCD 本身非常简单、易用，对于不复杂的多线程操 作，会节省代码量，而 Block 参数的使用，会是代码更为易读，建议在简单项目中 使用。</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="11-什么是-GCD-GCD-的队列类型"><a href="#11-什么是-GCD-GCD-的队列类型" class="headerlink" title="11. 什么是 GCD?GCD 的队列类型?"></a>11. 什么是 GCD?GCD 的队列类型?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">GCD(Grand Central Dispatch), 又叫做大中央调度, 它对线程操作进行了封装,加入了很多新的特性,内部进行了效率优化,提供了简洁的C语言接口, 使用更加高效,也是苹果推荐的使用方式.</span><br><span class="line"></span><br><span class="line">GCD的队列可以分为2大类型</span><br><span class="line"></span><br><span class="line">1.并发队列（Concurrent Dispatch Queue）</span><br><span class="line">可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务）</span><br><span class="line">并发功能只有在异步（dispatch_async）函数下才有效</span><br><span class="line"></span><br><span class="line">2.串行队列（Serial Dispatch Queue）</span><br><span class="line">让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务）,按照FIFO顺序执行.</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="12-什么是同步和异步任务派发-synchronous-和-asynchronous"><a href="#12-什么是同步和异步任务派发-synchronous-和-asynchronous" class="headerlink" title="12. 什么是同步和异步任务派发 (synchronous 和 asynchronous)?"></a>12. 什么是同步和异步任务派发 (synchronous 和 asynchronous)?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">GCD多线程经常会使用 dispatch_sync和dispatch_async函数向指定队列添加任务,分别是同步和异步</span><br><span class="line"></span><br><span class="line">同步：指阻塞当前线程,既要等待添加的耗时任务块Block完成后,函数才能返回,后面的代码才能继续执行</span><br><span class="line">异步：指将任务添加到队列后,函数立即返回,后面的代码不用等待添加的任务完成后即可执行,异步提交无法确定任务执行顺序</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="13-dispatch-barrier-a-sync-使用"><a href="#13-dispatch-barrier-a-sync-使用" class="headerlink" title="13.dispatch_barrier_(a)sync 使用?"></a>13.dispatch_barrier_(a)sync 使用?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">栅栏函数</span><br><span class="line"></span><br><span class="line">一个dispatch barrier 允许在一个并发队列中创建一个同步点。当在并发队列中遇到一个barrier, 他会延迟执行barrier的block,等待所有在barrier之前提交的blocks执行结束。 这时，barrier block自己开始执行。 之后， 队列继续正常的执行操作。</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="14-对称加密和非对称加密的区别？"><a href="#14-对称加密和非对称加密的区别？" class="headerlink" title="14. 对称加密和非对称加密的区别？"></a>14. 对称加密和非对称加密的区别？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">1、对称加密又称公开密钥加密，加密和解密都会用到同一个密钥，如果密钥被攻击者获得，此时加密就失去了意义。常见的对称加密算法有DES、3DES、AES、Blowfish、IDEA、RC5、RC6。</span><br><span class="line"></span><br><span class="line">2、非对称加密又称共享密钥加密，使用一对非对称的密钥，一把叫做私有密钥，另一把叫做公有密钥；公钥加密只能用私钥来解密，私钥加密只能用公钥来解密。常见的公钥加密算法有：RSA、ElGamal、背包算法、Rabin（RSA的特例）、迪菲－赫尔曼密钥交换协议中的公钥加密算法、椭圆曲线加密算法）。</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="15-组件化有什么好处？"><a href="#15-组件化有什么好处？" class="headerlink" title="15. 组件化有什么好处？"></a>15. 组件化有什么好处？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">业务分层、解耦，使代码变得可维护；</span><br><span class="line"></span><br><span class="line">有效的拆分、组织日益庞大的工程代码，使工程目录变得可维护；</span><br><span class="line"></span><br><span class="line">便于各业务功能拆分、抽离，实现真正的功能复用；</span><br><span class="line"></span><br><span class="line">业务隔离，跨团队开发代码控制和版本风险控制的实现；</span><br><span class="line"></span><br><span class="line">模块化对代码的封装性、合理性都有一定的要求，提升开发同学的设计能力；</span><br><span class="line"></span><br><span class="line">在维护好各级组件的情况下，随意组合满足不同客户需求；（只需要将之前的多个业务组件模块在新的主App中进行组装即可快速迭代出下一个全新App）</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="16-你是如何组件化解耦的？"><a href="#16-你是如何组件化解耦的？" class="headerlink" title="16. 你是如何组件化解耦的？"></a>16. 你是如何组件化解耦的？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">分层</span><br><span class="line"></span><br><span class="line">基础功能组件：按功能分库，不涉及产品业务需求，跟库Library类似，通过良好的接口拱上层业务组件调用；不写入产品定制逻辑，通过扩展接口完成定制；</span><br><span class="line"></span><br><span class="line">基础UI组件：各个业务模块依赖使用，但需要保持好定制扩展的设计</span><br><span class="line"></span><br><span class="line">业务组件：业务功能间相对独立，相互间没有Model共享的依赖；业务之间的页面调用只能通过UIBus进行跳转；业务之间的逻辑Action调用只能通过服务提供；</span><br><span class="line"></span><br><span class="line">中间件：target-action，url-block，protocol-class</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2a7e2aa0748b">iOS 组件化方案的几种实现</a></p>
<h3 id="17-APP-启动时间应从哪些方面优化？"><a href="#17-APP-启动时间应从哪些方面优化？" class="headerlink" title="17.APP 启动时间应从哪些方面优化？"></a>17.APP 启动时间应从哪些方面优化？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">App启动时间可以通过xcode提供的工具来度量，在Xcode的Product-&gt;Scheme--&gt;Edit Scheme-&gt;Run-&gt;Auguments中，将环境变量DYLD_PRINT_STATISTICS设为YES，优化需以下方面入手</span><br><span class="line"></span><br><span class="line">dylib loading time</span><br><span class="line"></span><br><span class="line">核心思想是减少dylibs的引用</span><br><span class="line"></span><br><span class="line">合并现有的dylibs（最好是6个以内）</span><br><span class="line"></span><br><span class="line">使用静态库</span><br><span class="line"></span><br><span class="line">rebase&#x2F;binding time</span><br><span class="line"></span><br><span class="line">核心思想是减少DATA块内的指针</span><br><span class="line"></span><br><span class="line">减少Object C元数据量，减少Objc类数量，减少实例变量和函数（与面向对象设计思想冲突）</span><br><span class="line"></span><br><span class="line">减少c++虚函数</span><br><span class="line"></span><br><span class="line">多使用Swift结构体（推荐使用swift）</span><br><span class="line"></span><br><span class="line">ObjC setup time</span><br><span class="line"></span><br><span class="line">核心思想同上，这部分内容基本上在上一阶段优化过后就不会太过耗时</span><br><span class="line"></span><br><span class="line">initializer time</span><br><span class="line"></span><br><span class="line">使用initialize替代load方法</span><br><span class="line"></span><br><span class="line">减少使用c&#x2F;c++的attribute((constructor))；推荐使用dispatch_once() pthread_once() std:once()等方法</span><br><span class="line"></span><br><span class="line">推荐使用swift</span><br><span class="line"></span><br><span class="line">不要在初始化中调用dlopen()方法，因为加载过程是单线程，无锁，如果调用dlopen则会变成多线程，会开启锁的消耗，同时有可能死锁</span><br><span class="line"></span><br><span class="line">不要在初始化中创建线程</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/27b2e9d744f0">iOS App 启动过程（一）：基础概念</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ff8d039195bf">iOS App 启动过程（二）：从 exec() 到 main()</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7fd94aead693">iOS App 启动过程（三）：main() 及生命周期</a></p>
<h1 id="Swift-系列面试题总结"><a href="#Swift-系列面试题总结" class="headerlink" title="Swift 系列面试题总结"></a>Swift 系列面试题总结</h1><h2 id="基础题：-1"><a href="#基础题：-1" class="headerlink" title="基础题："></a>基础题：</h2><h3 id="1-类-class-和-结构体-struct-有什么区别-类-class-和-结构体-struct-比较-优缺点"><a href="#1-类-class-和-结构体-struct-有什么区别-类-class-和-结构体-struct-比较-优缺点" class="headerlink" title="1. 类 (class) 和 结构体 (struct) 有什么区别? 类 (class) 和 结构体 (struct) 比较, 优缺点?"></a>1. 类 (class) 和 结构体 (struct) 有什么区别? 类 (class) 和 结构体 (struct) 比较, 优缺点?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">struct是值类型，class是引用类型。</span><br><span class="line"></span><br><span class="line">值类型的变量直接包含它们的数据，对于值类型都有它们自己的数据副本，因此对一个变量操作不可能影响另一个变量。</span><br><span class="line">引用类型的变量存储对他们的数据引用，因此后者称为对象，因此对一个变量操作可能影响另一个变量所引用的对象。</span><br><span class="line"></span><br><span class="line">二者的本质区别：struct是深拷贝，拷贝的是内容；class是浅拷贝，拷贝的是指针。</span><br><span class="line"></span><br><span class="line">property的初始化不同：class 在初始化时不能直接把 property 放在 默认的constructor 的参数里，而是需要自己创建一个带参数的constructor；而struct可以，把属性放在默认的constructor 的参数里。</span><br><span class="line">变量赋值方式不同：struct是值拷贝；class是引用拷贝。</span><br><span class="line">immutable变量：swift的可变内容和不可变内容用var和let来甄别，如果初始为let的变量再去修改会发生编译错误。struct遵循这一特性；class不存在这样的问题。</span><br><span class="line">mutating function： struct 和 class 的差別是 struct 的 function 要去改变 property 的值的时候要加上 mutating，而 class 不用。</span><br><span class="line">继承： struct不可以继承，class可以继承。</span><br><span class="line">struct比class更轻量：struct分配在栈中，class分配在堆中。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">class 有以下功能,struct 是没有的:</span><br><span class="line"></span><br><span class="line">class可以继承,子类可以使用父类的特性和方法</span><br><span class="line">类型转换可以在运行时检查和解释一个实例对象</span><br><span class="line">class可以用 deinit来释放资源</span><br><span class="line">一个类可以被多次引用</span><br><span class="line">struct 优势:</span><br><span class="line"></span><br><span class="line">结构较小,适用于复制操作,相比较一个class 实例被多次引用,struct 更安全</span><br><span class="line">无需担心内存泄露问题</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="2-Swift-是面向对象还是函数式的编程语言"><a href="#2-Swift-是面向对象还是函数式的编程语言" class="headerlink" title="2.Swift 是面向对象还是函数式的编程语言?"></a>2.Swift 是面向对象还是函数式的编程语言?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">Swift 既是面向对象的，又是函数式的编程语言。</span><br><span class="line">说 Swift 是面向对象的语言，是因为 Swift 支持类的封装、继承、和多态，从这点上来看与 Java 这类纯面向对象的语言几乎毫无差别。</span><br><span class="line">说 Swift 是函数式编程语言，是因为 Swift 支持 map, reduce, filter, flatmap 这类去除中间状态、数学函数式的方法，更加强调运算结果而不是中间过程。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="3-什么是泛型，swift-哪些地方使用了泛型？"><a href="#3-什么是泛型，swift-哪些地方使用了泛型？" class="headerlink" title="3. 什么是泛型，swift 哪些地方使用了泛型？"></a>3. 什么是泛型，swift 哪些地方使用了泛型？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">泛型（generic）可以使我们在程序代码中定义一些可变的部分，在运行的时候指定。使用泛型可以最大限度地重用代码、保护类型的安全以及提高性能。</span><br><span class="line">泛型可以将类型参数化，提高代码复用率，减少代码量。</span><br><span class="line"></span><br><span class="line">例如 optional 中的 map、flatMap 、?? (泛型加逃逸闭包的方式，做三目运算)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://www.runoob.com/swift/swift-generics.html">Swift 泛型</a></p>
<h3 id="4-swift-语法糖-？-！的本质（实现原理）"><a href="#4-swift-语法糖-？-！的本质（实现原理）" class="headerlink" title="4.swift 语法糖 ？ ！的本质（实现原理）"></a>4.swift 语法糖 ？ ！的本质（实现原理）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">？为optional的语法糖</span><br><span class="line">optional&lt;T&gt; 是一个包含了nil 和普通类型的枚举，确保使用者在变量为nil的情况下处理</span><br><span class="line"></span><br><span class="line">！为optional 强制解包的语法糖</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="5-什么是可选型-Optional-，Optional（可选型）-是用什么实现的"><a href="#5-什么是可选型-Optional-，Optional（可选型）-是用什么实现的" class="headerlink" title="5. 什么是可选型 (Optional)，Optional（可选型） 是用什么实现的"></a>5. 什么是可选型 (Optional)，Optional（可选型） 是用什么实现的</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">1.在 Swift 中,可选型是为了表达一个变量为空的情况,当一个变量为空,他的值就是 nil</span><br><span class="line">在类型名称后面加个问号? 来定义一个可选型</span><br><span class="line">值类型或者引用类型都可以是可选型变量</span><br><span class="line"></span><br><span class="line">2.Optional 是一个泛型枚举</span><br><span class="line">大致定义如下:</span><br><span class="line"></span><br><span class="line">enum Optional&lt;Wrapped&gt; &#123;</span><br><span class="line">  case none</span><br><span class="line">  case some(Wrapped)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">除了使用 let someValue: Int? &#x3D; nil 之外, 还可以使用let optional1: Optional&lt;Int&gt; &#x3D; nil 来定义</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="6-什么是高阶函数"><a href="#6-什么是高阶函数" class="headerlink" title="6. 什么是高阶函数"></a>6. 什么是高阶函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">一个函数如果可以以某一个函数作为参数, 或者是返回值, 那么这个函数就称之为高阶函数, 如 map, reduce, filter</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="7-如何解决引用循环"><a href="#7-如何解决引用循环" class="headerlink" title="7. 如何解决引用循环"></a>7. 如何解决引用循环</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">转换为值类型, 只有类会存在引用循环, 所以如果能不用类, 是可以解引用循环的,</span><br><span class="line">delegate 使用 weak 属性.</span><br><span class="line">闭包中, 对有可能发生循环引用的对象, 使用 weak 或者 unowned, 修饰</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="8-定义静态方法时关键字-static-和-class-有什么区别"><a href="#8-定义静态方法时关键字-static-和-class-有什么区别" class="headerlink" title="8. 定义静态方法时关键字 static 和 class 有什么区别"></a>8. 定义静态方法时关键字 static 和 class 有什么区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">static 定义的方法不可以被子类继承, class 则可以</span><br><span class="line"></span><br><span class="line">class AnotherClass &#123;</span><br><span class="line">    static func staticMethod()&#123;&#125;</span><br><span class="line">    class func classMethod()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class ChildOfAnotherClass: AnotherClass &#123;</span><br><span class="line">    override class func classMethod()&#123;&#125;</span><br><span class="line">    &#x2F;&#x2F;override static func staticMethod()&#123;&#125;&#x2F;&#x2F; error</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="9-请说明并比较以下关键词：Open-Public-Internal-File-private-Private"><a href="#9-请说明并比较以下关键词：Open-Public-Internal-File-private-Private" class="headerlink" title="9. 请说明并比较以下关键词：Open, Public, Internal, File-private, Private"></a>9. 请说明并比较以下关键词：Open, Public, Internal, File-private, Private</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">Swift 有五个级别的访问控制权限，从高到底依次为比如 Open, Public, Internal, File-private, Private。</span><br><span class="line"></span><br><span class="line">他们遵循的基本原则是：高级别的变量不允许被定义为低级别变量的成员变量。比如一个 private 的 class 中不能含有 public 的 String。反之，低级别的变量却可以定义在高级别的变量中。比如 public 的 class 中可以含有 private 的 Int。</span><br><span class="line"></span><br><span class="line">Open 具备最高的访问权限。其修饰的类和方法可以在任意 Module 中被访问和重写；它是 Swift 3 中新添加的访问权限。</span><br><span class="line">Public 的权限仅次于 Open。与 Open 唯一的区别在于它修饰的对象可以在任意 Module 中被访问，但不能重写。</span><br><span class="line">Internal 是默认的权限。它表示只能在当前定义的 Module 中访问和重写，它可以被一个 Module 中的多个文件访问，但不可以被其他的 Module 中被访问。</span><br><span class="line">File-private 也是 Swift 3 新添加的权限。其被修饰的对象只能在当前文件中被使用。例如它可以被一个文件中的 class，extension，struct 共同使用。</span><br><span class="line">Private 是最低的访问权限。它的对象只能在定义的作用域内使用。离开了这个作用域，即使是同一个文件中的其他作用域，也无法访问。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="10-swift-中-关键字-guard-和-defer-的用法-guard-也是基于一个表达式的布尔值去判断一段代码是否该被执行。与-if-语句不同的是，guard-只有在条件不满足的时候才会执行这段代码。"><a href="#10-swift-中-关键字-guard-和-defer-的用法-guard-也是基于一个表达式的布尔值去判断一段代码是否该被执行。与-if-语句不同的是，guard-只有在条件不满足的时候才会执行这段代码。" class="headerlink" title="10.swift 中, 关键字 guard 和 defer 的用法 guard 也是基于一个表达式的布尔值去判断一段代码是否该被执行。与 if 语句不同的是，guard 只有在条件不满足的时候才会执行这段代码。"></a>10.swift 中, 关键字 guard 和 defer 的用法 guard 也是基于一个表达式的布尔值去判断一段代码是否该被执行。与 if 语句不同的是，guard 只有在条件不满足的时候才会执行这段代码。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">guard let name &#x3D; self.text else &#123;  return &#125;</span><br><span class="line">复制代码</span><br><span class="line">defer的用法是，这条语句并不会马上执行，而是被推入栈中，直到函数结束时才再次被调用。</span><br><span class="line"></span><br><span class="line">defer &#123;</span><br><span class="line">   &#x2F;&#x2F;函数结束才调用</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="11-关键字-Strong-Weak-Unowned-区别"><a href="#11-关键字-Strong-Weak-Unowned-区别" class="headerlink" title="11. 关键字: Strong,Weak,Unowned 区别?"></a>11. 关键字: Strong,Weak,Unowned 区别?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">Swift 的内存管理机制同OC一致,都是ARC管理机制; Strong,和 Weak用法同OC一样</span><br><span class="line"></span><br><span class="line">Unowned(无主引用), 不会产生强引用，实例销毁后仍然存储着实例的内存地址(类似于OC中的unsafe_unretained), 试图在实例销毁后访问无主引用，会产生运行时错误(野指针)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="12-如何理解-copy-on-write"><a href="#12-如何理解-copy-on-write" class="headerlink" title="12. 如何理解 copy-on-write?"></a>12. 如何理解 copy-on-write?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">值类型(比如:struct),在复制时,复制对象与原对象实际上在内存中指向同一个对象,当且仅当修改复制的对象时,才会在内存中创建一个新的对象,</span><br><span class="line"></span><br><span class="line">为了提升性能，Struct, String、Array、Dictionary、Set采取了Copy On Write的技术</span><br><span class="line">比如仅当有“写”操作时，才会真正执行拷贝操作</span><br><span class="line">对于标准库值类型的赋值操作，Swift 能确保最佳性能，所有没必要为了保证最佳性能来避免赋值</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="13-什么是属性观察"><a href="#13-什么是属性观察" class="headerlink" title="13. 什么是属性观察?"></a>13. 什么是属性观察?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">属性观察是指在当前类型内对特性属性进行监测,并作出响应,属性观察是 swift 中的特性,具有2种, willset 和 didset</span><br><span class="line"></span><br><span class="line">var title: String &#123;</span><br><span class="line">    willSet &#123;</span><br><span class="line">        print(&quot;willSet&quot;, newValue)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    didSet &#123;</span><br><span class="line">        print(&quot;didSet&quot;, oldValue, title)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">willSet会传递新值，默认叫newValue</span><br><span class="line">didSet会传递旧值，默认叫oldValue</span><br><span class="line">在初始化器中设置属性值不会触发willSet和didSet</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="14-swift-为什么将-String-Array-Dictionary-设计为值类型"><a href="#14-swift-为什么将-String-Array-Dictionary-设计为值类型" class="headerlink" title="14.swift 为什么将 String,Array,Dictionary 设计为值类型?"></a>14.swift 为什么将 String,Array,Dictionary 设计为值类型?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">值类型和引用类型相比,最大优势可以高效的使用内存,值类型在栈上操作,引用类型在堆上操作,栈上操作仅仅是单个指针的移动,而堆上操作牵涉到合并,位移,重链接,Swift 这样设计减少了堆上内存分配和回收次数,使用 copy-on-write将值传递与复制开销降到最低</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="15-如何将-Swift-中的协议-protocol-中的部分方法设计为可选-optional"><a href="#15-如何将-Swift-中的协议-protocol-中的部分方法设计为可选-optional" class="headerlink" title="15.. 如何将 Swift 中的协议 (protocol) 中的部分方法设计为可选(optional)?"></a>15.. 如何将 Swift 中的协议 (protocol) 中的部分方法设计为可选(optional)?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">1.在协议和方法前面添加 @objc,然后在方法前面添加 optional关键字,改方式实际上是将协议转为了OC的方式</span><br><span class="line">@objc protocol someProtocol &#123;</span><br><span class="line">  @objc  optional func test()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2.使用扩展(extension),来规定可选方法,在 swift 中,协议扩展可以定义部分方法的默认实现</span><br><span class="line"></span><br><span class="line">protocol someProtocol &#123;</span><br><span class="line">    func test()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension someProtocol&#123;</span><br><span class="line">    func test() &#123;</span><br><span class="line">        print(&quot;test&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="16-比较-Swift-和-OC-中的初始化方法-init-有什么不同"><a href="#16-比较-Swift-和-OC-中的初始化方法-init-有什么不同" class="headerlink" title="16. 比较 Swift 和 OC 中的初始化方法 (init) 有什么不同?"></a>16. 比较 Swift 和 OC 中的初始化方法 (init) 有什么不同?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">swift 的初始化方法,更加严格和准确, swift初始化方法需要保证所有的非optional的成员变量都完成初始化, 同时 swfit 新增了convenience和 required两个修饰初始化器的关键字</span><br><span class="line"></span><br><span class="line">convenience只提供一种方便的初始化器,必须通过一个指定初始化器来完成初始化</span><br><span class="line">required是强制子类重写父类中所修饰的初始化方法</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="17-比较-Swift-和-OC-中的-protocol-有什么不同"><a href="#17-比较-Swift-和-OC-中的-protocol-有什么不同" class="headerlink" title="17. 比较 Swift 和 OC 中的 protocol 有什么不同?"></a>17. 比较 Swift 和 OC 中的 protocol 有什么不同?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">Swift 和OC中的 protocol相同点在于: 两者都可以被用作代理;</span><br><span class="line">不同点: Swift中的 protocol还可以对接口进行抽象,可以实现面向协议,从而大大提高编程效率,Swift中的protocol可以用于值类型,结构体,枚举;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="18-swift-和-OC-中的自省-有什么区别"><a href="#18-swift-和-OC-中的自省-有什么区别" class="headerlink" title="18.swift 和 OC 中的自省 有什么区别?"></a>18.swift 和 OC 中的自省 有什么区别?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">自省在OC中就是判断某一对象是否属于某一个类的操作,有以下2中方式</span><br><span class="line"></span><br><span class="line">[obj iskinOfClass:[SomeClass class]]</span><br><span class="line">[obj isMemberOfClass:[SomeClass class]]</span><br><span class="line"></span><br><span class="line">在 Swift 中由于很多 class 并非继承自 NSObject, 故而 Swift 使用 is 来判断是否属于某一类型, is 不仅可以作用于class, 还是作用于enum和struct</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="19-什么是函数重载-swift-支不支持函数重载"><a href="#19-什么是函数重载-swift-支不支持函数重载" class="headerlink" title="19. 什么是函数重载? swift 支不支持函数重载?"></a>19. 什么是函数重载? swift 支不支持函数重载?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">函数重载是指: 函数名称相同,函数的参数个数不同, 或者参数类型不同,或参数标签不同, 返回值类型与函数重载无关</span><br><span class="line"></span><br><span class="line">swift 支持函数重载</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="20-swift-中的枚举-关联值-和-原始值的区分"><a href="#20-swift-中的枚举-关联值-和-原始值的区分" class="headerlink" title="20.swift 中的枚举, 关联值 和 原始值的区分?"></a>20.swift 中的枚举, 关联值 和 原始值的区分?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">1.关联值--有时会将枚举的成员值跟其他类型的变量关联存储在一起，会非常有用</span><br><span class="line">&#x2F;&#x2F; 关联值</span><br><span class="line">enum Date &#123;</span><br><span class="line">  case digit(year: Int, month: Int, day: Int)</span><br><span class="line">  case string(String)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2.原始值--枚举成员可以使用相同类型的默认值预先关联，这个默认值叫做:原始值</span><br><span class="line">&#x2F;&#x2F; 原始值</span><br><span class="line">enum Grade: String &#123;</span><br><span class="line">  case perfect &#x3D; &quot;A&quot;</span><br><span class="line">  case great &#x3D; &quot;B&quot;</span><br><span class="line">  case good &#x3D; &quot;C&quot;</span><br><span class="line">  case bad &#x3D; &quot;D&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="21-swift-中的闭包结构是什么样子的-什么是尾随闭包-什么是逃逸闭包-什么是自动闭包"><a href="#21-swift-中的闭包结构是什么样子的-什么是尾随闭包-什么是逃逸闭包-什么是自动闭包" class="headerlink" title="21.swift 中的闭包结构是什么样子的? 什么是尾随闭包? 什么是逃逸闭包? 什么是自动闭包?"></a>21.swift 中的闭包结构是什么样子的? 什么是尾随闭包? 什么是逃逸闭包? 什么是自动闭包?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">1.</span><br><span class="line">&#123;</span><br><span class="line">    (参数列表) -&gt; 返回值类型 in 函数体代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">2.将一个很长的闭包表达式作为函数的最后一个实参</span><br><span class="line">  使用尾随闭包可以增强函数的可读性</span><br><span class="line">  尾随闭包是一个被书写在函数调用括号外面(后面)的闭包表达式</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; fn 就是一个尾随闭包参数</span><br><span class="line">func exec(v1: Int, v2: Int, fn: (Int, Int) -&gt; Int) &#123;</span><br><span class="line">    print(fn(v1, v2))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 调用</span><br><span class="line">exec(v1: 10, v2: 20) &#123;</span><br><span class="line">    $0 + $1</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">3.当闭包作为一个实际参数传递给一个函数或者变量的时候，我们就说这个闭包逃逸了，可以在形式参数前写 @escaping 来明确闭包是允许逃逸的。</span><br><span class="line"></span><br><span class="line">非逃逸闭包、逃逸闭包，一般都是当做参数传递给函数</span><br><span class="line">非逃逸闭包:闭包调用发生在函数结束前，闭包调用在函数作用域内</span><br><span class="line">逃逸闭包:闭包有可能在函数结束后调用，闭包调用逃离了函数的作用域，需要通过@escaping声明</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义一个数组用于存储闭包类型</span><br><span class="line">var completionHandlers: [() -&gt; Void] &#x3D; []</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  在方法中将闭包当做实际参数,存储到外部变量中</span><br><span class="line">func someFunctionWithEscapingClosure(completionHandler: @escaping () -&gt; Void) &#123;</span><br><span class="line">    completionHandlers.append(completionHandler)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">4.自动闭包是一种自动创建的用来把作为实际参数传递给函数的表达式打包的闭包。它不接受任何实际参数，并且当它被调用时，它会返回内部打包的表达式的值。这个语法的好处在于通过写普通表达式代替显式闭包而使你省略包围函数形式参数的括号。</span><br><span class="line"></span><br><span class="line">func getFirstPositive(_ v1: Int, _ v2: @autoclosure () -&gt; Int) -&gt; Int? &#123;</span><br><span class="line">    return v1 &gt; 0 ? v1 : v2()</span><br><span class="line">&#125;</span><br><span class="line">getFirstPositive(10, 20)</span><br><span class="line"></span><br><span class="line">为了避免与期望冲突，使用了@autoclosure的地方最好明确注释清楚:这个值会被推迟执行</span><br><span class="line">@autoclosure 会自动将 20 封装成闭包 &#123; 20 &#125;</span><br><span class="line">@autoclosure 只支持 () -&gt; T 格式的参数</span><br><span class="line">@autoclosure 并非只支持最后1个参数</span><br><span class="line">有@autoclosure、无@autoclosure，构成了函数重载</span><br><span class="line">如果你想要自动闭包允许逃逸，就同时使用 @autoclosure 和 @escaping 标志。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="22-swift-中-存储属性和计算属性的区别"><a href="#22-swift-中-存储属性和计算属性的区别" class="headerlink" title="22. swift 中, 存储属性和计算属性的区别?"></a>22. swift 中, 存储属性和计算属性的区别?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">Swift中跟实例对象相关的属性可以分为2大类</span><br><span class="line"></span><br><span class="line">存储属性(Stored Property)</span><br><span class="line"></span><br><span class="line">类似于成员变量这个概念</span><br><span class="line">存储在实例对象的内存中</span><br><span class="line">结构体、类可以定义存储属性</span><br><span class="line">枚举不可以定义存储属性</span><br><span class="line">计算属性(Computed Property)</span><br><span class="line"></span><br><span class="line">本质就是方法(函数)</span><br><span class="line">不占用实例对象的内存</span><br><span class="line">枚举、结构体、类都可以定义计算属性</span><br><span class="line"></span><br><span class="line">struct Circle &#123;</span><br><span class="line">    &#x2F;&#x2F; 存储属性</span><br><span class="line">    var radius: Double</span><br><span class="line">    &#x2F;&#x2F; 计算属性</span><br><span class="line">    var diameter: Double &#123;</span><br><span class="line">        set &#123;</span><br><span class="line">            radius &#x3D; newValue &#x2F; 2</span><br><span class="line">        &#125;</span><br><span class="line">        get &#123;</span><br><span class="line">            return radius * 2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="23-什么是延迟存储属性-Lazy-Stored-Property"><a href="#23-什么是延迟存储属性-Lazy-Stored-Property" class="headerlink" title="23. 什么是延迟存储属性 (Lazy Stored Property)?"></a>23. 什么是延迟存储属性 (Lazy Stored Property)?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">使用lazy可以定义一个延迟存储属性，在第一次用到属性的时候才会进行初始化(类似OC中的懒加载)</span><br><span class="line"></span><br><span class="line">lazy属性必须是var，不能是let</span><br><span class="line"> let必须在实例对象的初始化方法完成之前就拥有值</span><br><span class="line">如果多条线程同时第一次访问lazy属性</span><br><span class="line"> 无法保证属性只被初始化1次</span><br><span class="line"></span><br><span class="line"> class PhotoView &#123;</span><br><span class="line">    &#x2F;&#x2F; 延迟存储属性</span><br><span class="line">    lazy var image: Image &#x3D; &#123;</span><br><span class="line">        let url &#x3D; &quot;https:&#x2F;&#x2F;...x.png&quot;        </span><br><span class="line">        let data &#x3D; Data(url: url)</span><br><span class="line">        return Image(data: data)</span><br><span class="line">    &#125;() </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="24-swift-中如何使用单例模式"><a href="#24-swift-中如何使用单例模式" class="headerlink" title="24.swift 中如何使用单例模式?"></a>24.swift 中如何使用单例模式?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">可以通过类型属性+let+private 来写单例; 代码如下如下:</span><br><span class="line"></span><br><span class="line"> public class FileManager &#123;</span><br><span class="line">    public static let shared &#x3D; &#123;</span><br><span class="line">        &#x2F;&#x2F; ....</span><br><span class="line">        &#x2F;&#x2F; ....</span><br><span class="line">        return FileManager()</span><br><span class="line">&#125;()</span><br><span class="line">    private init() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="25-swift-中的下标是什么"><a href="#25-swift-中的下标是什么" class="headerlink" title="25.swift 中的下标是什么?"></a>25.swift 中的下标是什么?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">使用subscript可以给任意类型(枚举、结构体、类)增加下标功能，有些地方也翻译为:下标脚本</span><br><span class="line">subscript的语法类似于实例方法、计算属性，本质就是方法(函数)</span><br><span class="line"></span><br><span class="line">使用如下:</span><br><span class="line">class Point &#123;</span><br><span class="line">    var x &#x3D; 0.0, y &#x3D; 0.0</span><br><span class="line">    subscript(index: Int) -&gt; Double &#123;</span><br><span class="line">        set &#123;</span><br><span class="line">            if index &#x3D;&#x3D; 0 &#123;</span><br><span class="line">                x &#x3D; newValue</span><br><span class="line">            &#125; else if index &#x3D;&#x3D; 1 &#123;</span><br><span class="line">                y &#x3D; newValue &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        get &#123;</span><br><span class="line">            if index &#x3D;&#x3D; 0 &#123;</span><br><span class="line">                return x</span><br><span class="line">            &#125; else if index &#x3D;&#x3D; 1 &#123;</span><br><span class="line">                return y</span><br><span class="line">            &#125;</span><br><span class="line">            return 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p &#x3D; Point()</span><br><span class="line">&#x2F;&#x2F; 下标赋值</span><br><span class="line">p[0] &#x3D; 11.1</span><br><span class="line">p[1] &#x3D; 22.2</span><br><span class="line">&#x2F;&#x2F; 下标访问</span><br><span class="line">print(p.x) &#x2F;&#x2F; 11.1</span><br><span class="line">print(p.y) &#x2F;&#x2F; 22.2</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="26-简要说明-Swift-中的初始化器"><a href="#26-简要说明-Swift-中的初始化器" class="headerlink" title="26. 简要说明 Swift 中的初始化器?"></a>26. 简要说明 Swift 中的初始化器?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">类、结构体、枚举都可以定义初始化器</span><br><span class="line">类有2种初始化器: 指定初始化器(designated initializer)、便捷初始化器(convenience initializer)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 指定初始化器 </span><br><span class="line">init(parameters) &#123;</span><br><span class="line">    statements </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 便捷初始化器</span><br><span class="line">convenience init(parameters) &#123;</span><br><span class="line">    statements </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">规则:</span><br><span class="line"></span><br><span class="line">每个类至少有一个指定初始化器，指定初始化器是类的主要初始化器</span><br><span class="line">默认初始化器总是类的指定初始化器</span><br><span class="line">类偏向于少量指定初始化器，一个类通常只有一个指定初始化器</span><br><span class="line">初始化器的相互调用规则</span><br><span class="line"></span><br><span class="line">指定初始化器必须从它的直系父类调用指定初始化器</span><br><span class="line">便捷初始化器必须从相同的类里调用另一个初始化器</span><br><span class="line">便捷初始化器最终必须调用一个指定初始化器</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="27-什么可选链"><a href="#27-什么可选链" class="headerlink" title="27. 什么可选链?"></a>27. 什么可选链?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">可选链是一个调用和查询可选属性、方法和下标的过程，它可能为 nil 。如果可选项包含值，属性、方法或者下标的调用成功；如果可选项是 nil ，属性、方法或者下标的调用会返回 nil 。多个查询可以链接在一起，如果链中任何一个节点是 nil ，那么整个链就会得体地失败。</span><br><span class="line"></span><br><span class="line">多个?可以链接在一起</span><br><span class="line">如果链中任何一个节点是nil，那么整个链就会调用失败</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="28-什么是运算符重载-Operator-Overload"><a href="#28-什么是运算符重载-Operator-Overload" class="headerlink" title="28. 什么是运算符重载 (Operator Overload)?"></a>28. 什么是运算符重载 (Operator Overload)?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">类、结构体、枚举可以为现有的运算符提供自定义的实现，这个操作叫做:运算符重载</span><br><span class="line"></span><br><span class="line">struct Point &#123;</span><br><span class="line">    var x: Int</span><br><span class="line">    var y: Int</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 重载运算符</span><br><span class="line">    static func + (p1: Point, p2: Point) -&gt; Point   &#123;</span><br><span class="line">        return Point(x: p1.x + p2.x, y: p1.y + p2.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p1 &#x3D; Point(x: 10, y: 10)</span><br><span class="line">var p2 &#x3D; Point(x: 20, y: 20)</span><br><span class="line">var p3 &#x3D; p1 + p2</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

<div>
  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
  
</div>

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/iOS-%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag"><i class="fa fa-tag"></i># iOS 面试题</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/01/10/iOS-%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E5%A4%AF%E5%AE%9E%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0-6%EF%BC%89/" rel="prev" title="iOS - 面试题 性能优化（夯实基础学习笔记 - 温故知新 6）">
      <i class="fa fa-chevron-left"></i> iOS - 面试题 性能优化（夯实基础学习笔记 - 温故知新 6）
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/01/10/2020-%E5%B9%B4%E9%9D%A2%E8%AF%95%EF%BC%9A%E6%95%B4%E7%90%86%E5%87%BA%E4%B8%80%E4%BB%BD%E9%AB%98%E7%BA%A7-iOS-%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="next" title="2020 年面试：整理出一份高级 iOS 面试题">
      2020 年面试：整理出一份高级 iOS 面试题 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Object-C-%E7%B3%BB%E5%88%97%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93"><span class="nav-number">1.</span> <span class="nav-text">Object-C 系列面试题总结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E9%A2%98%EF%BC%9A"><span class="nav-number">1.1.</span> <span class="nav-text">基础题：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Objective-C-%E7%9A%84%E7%B1%BB%E5%8F%AF%E4%BB%A5%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E4%B9%88%EF%BC%9F%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3%E4%B9%88%EF%BC%9FCategory-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E9%87%8D%E5%86%99%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E6%96%B9%E5%BC%8F%E7%94%A8%E7%BB%A7%E6%89%BF%E5%A5%BD%E8%BF%98%E6%98%AF%E5%88%86%E7%B1%BB%E5%A5%BD%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%A6%81%E5%9C%A8-category-%E4%B8%AD%E9%87%8D%E5%86%99%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%8E%9F%E6%9C%89%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.Objective-C 的类可以多重继承么？可以实现多个接口么？Category 是什么？重写一个类的方式用继承好还是分类好？为什么不要在 category 中重写一个类原有的方法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%AF%B7%E8%AF%B4%E6%98%8E%E5%B9%B6%E6%AF%94%E8%BE%83%E4%BB%A5%E4%B8%8B%E5%85%B3%E9%94%AE%E8%AF%8D%EF%BC%9Astrong-weak-assign-copy%E3%80%82"><span class="nav-number">1.1.2.</span> <span class="nav-text">2. 请说明并比较以下关键词：strong, weak, assign, copy。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E7%94%A8-property-%E5%A3%B0%E6%98%8E%E7%9A%84-NSString-NSArray-NSDictionary-%E7%BB%8F%E5%B8%B8%E4%BD%BF%E7%94%A8-copy-%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E6%9E%9C%E6%94%B9%E7%94%A8-strong-%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%8C%E5%8F%AF%E8%83%BD%E9%80%A0%E6%88%90%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">1.1.3.</span> <span class="nav-text">3. 用 @property 声明的 NSString &#x2F; NSArray &#x2F; NSDictionary 经常使用 copy 关键字，为什么？如果改用 strong 关键字，可能造成什么问题？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.1.4.</span> <span class="nav-text">4. 浅拷贝和深拷贝的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Objective-C-%E5%A6%82%E4%BD%95%E5%AF%B9%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%EF%BC%8C%E8%AF%B4%E8%AF%B4%E4%BD%A0%E7%9A%84%E7%9C%8B%E6%B3%95%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-number">1.1.5.</span> <span class="nav-text">5.Objective-C 如何对内存管理的，说说你的看法和解决方法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E7%BB%A7%E6%89%BF%E3%80%81%E5%88%86%E7%B1%BB%E5%92%8C%E7%B1%BB%E6%89%A9%E5%B1%95"><span class="nav-number">1.1.6.</span> <span class="nav-text">6. 继承、分类和类扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E6%88%91%E4%BB%AC%E8%AF%B4%E7%9A%84-OC-%E6%98%AF%E5%8A%A8%E6%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%AD%E8%A8%80%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F"><span class="nav-number">1.1.7.</span> <span class="nav-text">7. 我们说的 OC 是动态运行时语言是什么意思？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E4%BB%80%E4%B9%88%E6%98%AF-KVO-%E5%92%8C-KVC%EF%BC%9F%E8%B0%88%E8%B0%88-KVC-%E4%BB%A5%E5%8F%8A-KVO-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="nav-number">1.1.8.</span> <span class="nav-text">8. 什么是 KVO 和 KVC？谈谈 KVC 以及 KVO 的理解？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-block-%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="nav-number">1.1.9.</span> <span class="nav-text">9.block 的注意点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E5%A0%86%E3%80%81%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="nav-number">1.1.10.</span> <span class="nav-text">10. 堆、栈和队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E6%80%81-%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E7%B1%BB-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.1.11.</span> <span class="nav-text">11. 什么是多态? 什么是分类? 什么是协议?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-UIView-%E5%92%8C-CALayer-%E6%98%AF%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="nav-number">1.1.12.</span> <span class="nav-text">12.UIView 和 CALayer 是什么关系？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-%E8%AF%B4%E4%B8%80%E4%B8%8B-JS-%E5%92%8C-OC-%E4%BA%92%E7%9B%B8%E8%B0%83%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-number">1.1.13.</span> <span class="nav-text">13. 说一下 JS 和 OC 互相调用的几种方式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-HTTP-Http-%E5%92%8C-Https-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9FHttps-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9B%B4%E5%8A%A0%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="nav-number">1.1.14.</span> <span class="nav-text">14. 如何理解 HTTP?&#x2F;Http 和 Https 的区别？Https 为什么更加安全？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%EF%BC%9F"><span class="nav-number">1.1.15.</span> <span class="nav-text">15. 编程中的六大设计原则？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-Objective-C-%E4%B8%8E-Swift-%E7%9A%84%E5%BC%82%E5%90%8C%EF%BC%9F"><span class="nav-number">1.1.16.</span> <span class="nav-text">16.Objective-C 与 Swift 的异同？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-%E6%B2%99%E7%9B%92%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F%E5%90%84%E8%87%AA%E7%94%A8%E4%BA%8E%E9%82%A3%E4%BA%9B%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="nav-number">1.1.17.</span> <span class="nav-text">17. 沙盒目录结构是怎样的？各自用于那些场景？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-iOS-%E4%B8%AD%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E6%A1%88%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">1.1.18.</span> <span class="nav-text">17.iOS 中数据持久化方案有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-%E5%8D%95%E4%B8%AA-viewController-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F"><span class="nav-number">1.1.19.</span> <span class="nav-text">18. 单个 viewController 的生命周期？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-cocoa-%E5%92%8C-cocoa-touch-%E6%98%AF%E4%BB%80%E4%B9%88-cocoa-touch-%E5%BA%95%E5%B1%82%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84"><span class="nav-number">1.1.20.</span> <span class="nav-text">19.cocoa 和 cocoa touch 是什么?&#x2F;cocoa touch 底层技术架构?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9-delegate%E3%80%81notification%E3%80%81KVO%EF%BC%9F"><span class="nav-number">1.1.21.</span> <span class="nav-text">20. 如何选择 delegate、notification、KVO？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-%E5%B9%B3%E6%97%B6%E5%BC%80%E5%8F%91%E6%9C%89%E6%B2%A1%E6%9C%89%E7%8E%A9%E8%BF%87-Instrument-%EF%BC%9F"><span class="nav-number">1.1.22.</span> <span class="nav-text">21. 平时开发有没有玩过 Instrument ？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-number">1.1.23.</span> <span class="nav-text">常用的排序算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SDWebImage-%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%89%87%E8%BF%87%E7%A8%8B"><span class="nav-number">1.1.24.</span> <span class="nav-text">SDWebImage 加载图片过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AFNetworking-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="nav-number">1.1.25.</span> <span class="nav-text">AFNetworking 底层原理分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E9%98%B6%E9%A2%98%EF%BC%9A"><span class="nav-number">1.2.</span> <span class="nav-text">进阶题：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-KVC-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.KVC 的底层实现？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-KVO-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.KVO 的底层实现？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%B7%A5%E4%BD%9C%E4%B8%AD%E4%BD%A0%E6%80%8E%E4%B9%88%E5%81%9A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84"><span class="nav-number">1.2.3.</span> <span class="nav-text">3. 说一下工作中你怎么做性能优化的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Runtime-%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88%E4%BA%8B%E6%83%85%E5%91%A2%EF%BC%9F"><span class="nav-number">1.2.4.</span> <span class="nav-text">5.Runtime 实现的机制是什么？能做什么事情呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-iOS-%E5%9B%BE%E7%89%87%E8%AE%BE%E7%BD%AE%E5%9C%86%E8%A7%92%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="nav-number">1.2.5.</span> <span class="nav-text">6.iOS 图片设置圆角性能问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E4%BB%80%E4%B9%88%E6%98%AF-RunLoop%EF%BC%9F"><span class="nav-number">1.2.6.</span> <span class="nav-text">7. 什么是 RunLoop？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E4%BB%A5-scheduledTimerWithTimeInterval-%E7%9A%84%E6%96%B9%E5%BC%8F%E8%A7%A6%E5%8F%91%E7%9A%84-timer%EF%BC%8C%E5%9C%A8%E6%BB%91%E5%8A%A8%E9%A1%B5%E9%9D%A2%E4%B8%8A%E7%9A%84%E5%88%97%E8%A1%A8%E6%97%B6%EF%BC%8Ctimer-%E4%BC%9A%E6%9A%82%E5%81%9C%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F%E8%AF%A5%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="nav-number">1.2.7.</span> <span class="nav-text">8. 以 scheduledTimerWithTimeInterval 的方式触发的 timer，在滑动页面上的列表时，timer 会暂停，为什么？该如何解决？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.2.8.</span> <span class="nav-text">9. 进程与线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-iOS-%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%A1%88%EF%BC%8C%E5%90%84%E8%87%AA%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F%E8%AE%B2%E4%B8%80%E4%B8%8B%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%80%89%E6%8B%A9%E4%BD%BF%E7%94%A8-GCD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%80%89-%E6%8B%A9-NSOperation"><span class="nav-number">1.2.9.</span> <span class="nav-text">10.iOS 中实现多线程的几种方案，各自有什么特点？讲一下具体使用场景 &#x2F; 在项目什么时候选择使用 GCD，什么时候选 择 NSOperation?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E4%BB%80%E4%B9%88%E6%98%AF-GCD-GCD-%E7%9A%84%E9%98%9F%E5%88%97%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.10.</span> <span class="nav-text">11. 什么是 GCD?GCD 的队列类型?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E6%B4%BE%E5%8F%91-synchronous-%E5%92%8C-asynchronous"><span class="nav-number">1.2.11.</span> <span class="nav-text">12. 什么是同步和异步任务派发 (synchronous 和 asynchronous)?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-dispatch-barrier-a-sync-%E4%BD%BF%E7%94%A8"><span class="nav-number">1.2.12.</span> <span class="nav-text">13.dispatch_barrier_(a)sync 使用?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.2.13.</span> <span class="nav-text">14. 对称加密和非对称加密的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-%E7%BB%84%E4%BB%B6%E5%8C%96%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="nav-number">1.2.14.</span> <span class="nav-text">15. 组件化有什么好处？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-%E4%BD%A0%E6%98%AF%E5%A6%82%E4%BD%95%E7%BB%84%E4%BB%B6%E5%8C%96%E8%A7%A3%E8%80%A6%E7%9A%84%EF%BC%9F"><span class="nav-number">1.2.15.</span> <span class="nav-text">16. 你是如何组件化解耦的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-APP-%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4%E5%BA%94%E4%BB%8E%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="nav-number">1.2.16.</span> <span class="nav-text">17.APP 启动时间应从哪些方面优化？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Swift-%E7%B3%BB%E5%88%97%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93"><span class="nav-number">2.</span> <span class="nav-text">Swift 系列面试题总结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E9%A2%98%EF%BC%9A-1"><span class="nav-number">2.1.</span> <span class="nav-text">基础题：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%B1%BB-class-%E5%92%8C-%E7%BB%93%E6%9E%84%E4%BD%93-struct-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB-%E7%B1%BB-class-%E5%92%8C-%E7%BB%93%E6%9E%84%E4%BD%93-struct-%E6%AF%94%E8%BE%83-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">2.1.1.</span> <span class="nav-text">1. 类 (class) 和 结构体 (struct) 有什么区别? 类 (class) 和 结构体 (struct) 比较, 优缺点?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Swift-%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%98%E6%98%AF%E5%87%BD%E6%95%B0%E5%BC%8F%E7%9A%84%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80"><span class="nav-number">2.1.2.</span> <span class="nav-text">2.Swift 是面向对象还是函数式的编程语言?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B%EF%BC%8Cswift-%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%E4%BD%BF%E7%94%A8%E4%BA%86%E6%B3%9B%E5%9E%8B%EF%BC%9F"><span class="nav-number">2.1.3.</span> <span class="nav-text">3. 什么是泛型，swift 哪些地方使用了泛型？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-swift-%E8%AF%AD%E6%B3%95%E7%B3%96-%EF%BC%9F-%EF%BC%81%E7%9A%84%E6%9C%AC%E8%B4%A8%EF%BC%88%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%89"><span class="nav-number">2.1.4.</span> <span class="nav-text">4.swift 语法糖 ？ ！的本质（实现原理）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E9%80%89%E5%9E%8B-Optional-%EF%BC%8COptional%EF%BC%88%E5%8F%AF%E9%80%89%E5%9E%8B%EF%BC%89-%E6%98%AF%E7%94%A8%E4%BB%80%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="nav-number">2.1.5.</span> <span class="nav-text">5. 什么是可选型 (Optional)，Optional（可选型） 是用什么实现的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E4%BB%80%E4%B9%88%E6%98%AF%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="nav-number">2.1.6.</span> <span class="nav-text">6. 什么是高阶函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BC%95%E7%94%A8%E5%BE%AA%E7%8E%AF"><span class="nav-number">2.1.7.</span> <span class="nav-text">7. 如何解决引用循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E5%AE%9A%E4%B9%89%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E6%97%B6%E5%85%B3%E9%94%AE%E5%AD%97-static-%E5%92%8C-class-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">2.1.8.</span> <span class="nav-text">8. 定义静态方法时关键字 static 和 class 有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E8%AF%B7%E8%AF%B4%E6%98%8E%E5%B9%B6%E6%AF%94%E8%BE%83%E4%BB%A5%E4%B8%8B%E5%85%B3%E9%94%AE%E8%AF%8D%EF%BC%9AOpen-Public-Internal-File-private-Private"><span class="nav-number">2.1.9.</span> <span class="nav-text">9. 请说明并比较以下关键词：Open, Public, Internal, File-private, Private</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-swift-%E4%B8%AD-%E5%85%B3%E9%94%AE%E5%AD%97-guard-%E5%92%8C-defer-%E7%9A%84%E7%94%A8%E6%B3%95-guard-%E4%B9%9F%E6%98%AF%E5%9F%BA%E4%BA%8E%E4%B8%80%E4%B8%AA%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%B8%83%E5%B0%94%E5%80%BC%E5%8E%BB%E5%88%A4%E6%96%AD%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%E6%98%AF%E5%90%A6%E8%AF%A5%E8%A2%AB%E6%89%A7%E8%A1%8C%E3%80%82%E4%B8%8E-if-%E8%AF%AD%E5%8F%A5%E4%B8%8D%E5%90%8C%E7%9A%84%E6%98%AF%EF%BC%8Cguard-%E5%8F%AA%E6%9C%89%E5%9C%A8%E6%9D%A1%E4%BB%B6%E4%B8%8D%E6%BB%A1%E8%B6%B3%E7%9A%84%E6%97%B6%E5%80%99%E6%89%8D%E4%BC%9A%E6%89%A7%E8%A1%8C%E8%BF%99%E6%AE%B5%E4%BB%A3%E7%A0%81%E3%80%82"><span class="nav-number">2.1.10.</span> <span class="nav-text">10.swift 中, 关键字 guard 和 defer 的用法 guard 也是基于一个表达式的布尔值去判断一段代码是否该被执行。与 if 语句不同的是，guard 只有在条件不满足的时候才会执行这段代码。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E5%85%B3%E9%94%AE%E5%AD%97-Strong-Weak-Unowned-%E5%8C%BA%E5%88%AB"><span class="nav-number">2.1.11.</span> <span class="nav-text">11. 关键字: Strong,Weak,Unowned 区别?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-copy-on-write"><span class="nav-number">2.1.12.</span> <span class="nav-text">12. 如何理解 copy-on-write?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-%E4%BB%80%E4%B9%88%E6%98%AF%E5%B1%9E%E6%80%A7%E8%A7%82%E5%AF%9F"><span class="nav-number">2.1.13.</span> <span class="nav-text">13. 什么是属性观察?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-swift-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B0%86-String-Array-Dictionary-%E8%AE%BE%E8%AE%A1%E4%B8%BA%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.1.14.</span> <span class="nav-text">14.swift 为什么将 String,Array,Dictionary 设计为值类型?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-%E5%A6%82%E4%BD%95%E5%B0%86-Swift-%E4%B8%AD%E7%9A%84%E5%8D%8F%E8%AE%AE-protocol-%E4%B8%AD%E7%9A%84%E9%83%A8%E5%88%86%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%BA%E5%8F%AF%E9%80%89-optional"><span class="nav-number">2.1.15.</span> <span class="nav-text">15.. 如何将 Swift 中的协议 (protocol) 中的部分方法设计为可选(optional)?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-%E6%AF%94%E8%BE%83-Swift-%E5%92%8C-OC-%E4%B8%AD%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95-init-%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C"><span class="nav-number">2.1.16.</span> <span class="nav-text">16. 比较 Swift 和 OC 中的初始化方法 (init) 有什么不同?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-%E6%AF%94%E8%BE%83-Swift-%E5%92%8C-OC-%E4%B8%AD%E7%9A%84-protocol-%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C"><span class="nav-number">2.1.17.</span> <span class="nav-text">17. 比较 Swift 和 OC 中的 protocol 有什么不同?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-swift-%E5%92%8C-OC-%E4%B8%AD%E7%9A%84%E8%87%AA%E7%9C%81-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">2.1.18.</span> <span class="nav-text">18.swift 和 OC 中的自省 有什么区别?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD-swift-%E6%94%AF%E4%B8%8D%E6%94%AF%E6%8C%81%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="nav-number">2.1.19.</span> <span class="nav-text">19. 什么是函数重载? swift 支不支持函数重载?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-swift-%E4%B8%AD%E7%9A%84%E6%9E%9A%E4%B8%BE-%E5%85%B3%E8%81%94%E5%80%BC-%E5%92%8C-%E5%8E%9F%E5%A7%8B%E5%80%BC%E7%9A%84%E5%8C%BA%E5%88%86"><span class="nav-number">2.1.20.</span> <span class="nav-text">20.swift 中的枚举, 关联值 和 原始值的区分?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-swift-%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90%E7%9A%84-%E4%BB%80%E4%B9%88%E6%98%AF%E5%B0%BE%E9%9A%8F%E9%97%AD%E5%8C%85-%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%83%E9%80%B8%E9%97%AD%E5%8C%85-%E4%BB%80%E4%B9%88%E6%98%AF%E8%87%AA%E5%8A%A8%E9%97%AD%E5%8C%85"><span class="nav-number">2.1.21.</span> <span class="nav-text">21.swift 中的闭包结构是什么样子的? 什么是尾随闭包? 什么是逃逸闭包? 什么是自动闭包?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-swift-%E4%B8%AD-%E5%AD%98%E5%82%A8%E5%B1%9E%E6%80%A7%E5%92%8C%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.1.22.</span> <span class="nav-text">22. swift 中, 存储属性和计算属性的区别?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BB%B6%E8%BF%9F%E5%AD%98%E5%82%A8%E5%B1%9E%E6%80%A7-Lazy-Stored-Property"><span class="nav-number">2.1.23.</span> <span class="nav-text">23. 什么是延迟存储属性 (Lazy Stored Property)?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-swift-%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.1.24.</span> <span class="nav-text">24.swift 中如何使用单例模式?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-swift-%E4%B8%AD%E7%9A%84%E4%B8%8B%E6%A0%87%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">2.1.25.</span> <span class="nav-text">25.swift 中的下标是什么?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26-%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8E-Swift-%E4%B8%AD%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8"><span class="nav-number">2.1.26.</span> <span class="nav-text">26. 简要说明 Swift 中的初始化器?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#27-%E4%BB%80%E4%B9%88%E5%8F%AF%E9%80%89%E9%93%BE"><span class="nav-number">2.1.27.</span> <span class="nav-text">27. 什么可选链?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#28-%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-Operator-Overload"><span class="nav-number">2.1.28.</span> <span class="nav-text">28. 什么是运算符重载 (Operator Overload)?</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Arise"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Arise</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Arise903" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Arise903" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:li13474514659@gmail.com" title="E-Mail → mailto:li13474514659@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/Arise08" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;Arise08" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/arise.li.12" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;arise.li.12" rel="noopener" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Arise</span>
</div>

<!---->

<span id="busuanzi_container_site_uv">
  本站访问次数：<span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
</span>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共32.2k字</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>
    <script defer src="/lib/three/canvas_sphere.min.js"></script>


  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : '2e4EG1iiDMWDH41h7EFQyjBy-gzGzoHsz',
      appKey     : 'Sy8hnfuBbs5vw8Bw0dKNVw8z',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>


    
<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
